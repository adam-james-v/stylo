* ;;
#+Title: stylo
#+SUBTITLE: document rendering library
#+AUTHOR: adam-james
#+STARTUP: overview
#+PROPERTY: header-args :cache yes :noweb yes :results inline :mkdirp yes :padline yes :async
#+HTML_DOCTYPE: html5
#+OPTIONS: toc:2 num:nil html-style:nil html-postamble:nil html-preamble:nil html5-fancy:t

** deps.edn
I intend to have stylo work in both clj/cljs contexts. As such, I need both clojure and clojurescript dependencies.

Some additional notes about deps:

- hiccup is clj only, hench macchiato/hiccups, which seems to be a near 1-1 port of hiccup to cljs
  - might be worth finding an alternative to hiccup that works in both clj/cljs so that I don't have to write conditionals in my src files

- I don't yet know if spec.alpha works in clojurescript
  - if it does, there is not change needed
  - if it does not, I will need to write in such a way that I can still build to cljs contexts by excluding spec.
    - this may simply be an alias in deps.edn
    - might require wrapping spec defs in reader conditionals

- garden (the css compiling lib.) works in cljs

- instaparse also works in both clj and cljs

#+NAME: deps.edn
#+begin_src clojure :tangle ./deps.edn
{:paths
 ["src" "tests" "./"]
 
 :deps 
 {org.clojure/clojure            {:mvn/version "1.10.1"}
  org.clojure/clojurescript      {:mvn/version "1.10.597"}
  org.clojure/test.check         {:mvn/version "0.9.0"}
  org.clojure/spec.alpha         {:mvn/version "0.2.187"}
  hiccup                         {:mvn/version "2.0.0-alpha2"}
  macchiato/hiccups              {:mvn/version "0.4.1"}
  garden                         {:mvn/version "1.3.9"}
  instaparse                     {:mvn/version "1.4.10"}
  ubergraph                      {:mvn/version "0.8.2"}}}

#+end_src

** utilities
*** watcher script
Currently this script is called ~stylo-watch~ and will only work from within the stylo project (since clj is not being passed any classpath information)

#+BEGIN_SRC bash
#!/bin/bash
ECHO "watching: " $1
cd ~/dev/stylo/ && fswatch $1 | xargs -n1 -I{} clj -m stylo.builder {}
#+END_SRC

I have a copy of ~stylo-watch~ in ~/usr/local/bin/~ so I can call stylo-watch as a command in my terminal.

It is very important to update that script or remove it when I have a production-ready method for watch/build.

*** build
 This code snippet will build an executable. It uses node.js and cljs only.

 #+begin_src clojure
 (require 'cljs.build.api)
 (cljs.build.api/build "src" {:optimizations :advanced :output-to "out/main.js"})

 (use '[clojure.java.shell :only [sh]])
 #_(sh "nexe -i out/main.js -o stylo.exe")

 #+end_src
* design
** goals
I want to blend CAD and documentation into one simple, powerful, useful, and open library. Stylo approaches this problem by assuming the document IS the design, including prose, interactice elements, and 2D/3D figures. Export into popular formats is a must.

** concept
This program takes a document and renders it.

The intent is to have a plaintext file format. Markdown and org files are good examples. These files will have a simple syntax which allows text and code. The user can use or create 'extensions' which allow for more specialized sections in the documents. For example, github flavoured markdown has a more advanced concept of tables than the original specification of markdown.

These extensions will each have their own DSL which can be used directly in the plaintext document.

Users can write their document, run the stylo program binary on their file, and expect to see an .html file which fully contains their rendered work.

The rendered document is 'standalone'. It is (ideally) a single file (all images, and interactive elements are embedded).

Any interactive components in the document are fully contained in the file so that no internet connection is required.

*** pragmatic

 - it should be optional to render documents with links to a ./resources/ folder containing images (no embedding) to keep files smaller
 - for interactive elements, it may be simpler to distribute/keep files small by rendering with cdn links to js plugins
   - if there is a 3D viewer using three.js or babylon.js, it might be a better approach to NOT include the entire js library in the document and instead use a script tag with a link to the cdn.

** workflow
- user creates a new document in their editor of choice
- at the top of the file, the user can list the extensions they wish to use (if no list is provided, sensible defaults exist in the core library already)
- user runs the stylo program from the terminal, passing in the file as an arg.
- a file watcher is spawned and the document is rendered to an html file, and the file opens in the user's default browser
- changes to the document are detected and the html file is re-rendered and the browser refreshed.
- when the user is finished, they have both the source document and the finished html file to distribute as they wish.

This setup allows users to edit documents however they want and still see their changes live in the browser. This is a really nice way to work allowing for incremental improvements to the document. This is similar to how Clojure has a really nice REPL allowing for progams to be built up in small pieces.
** structure
Use graphs for everything.
NODES are all geometric entities:
 - points
 - curves/lines
 - faces
 - solids

EDGES are the ways in which the entities are related:
 - points-begins->line<-ends-points
 - solid -> face -> curve -> pt

The NODES will contain the BREP and FREP functions as well as any other computationally useful data. For instance, face could have a :hole true key to 'hint' the renders.

Not every possible relationship needs to be built up front. For example, it might make sense to compute center points into the graph later on (eg. center of face is a point that has a relation TO the face not necessarily FROM the face.

Do EDGES have properties of their own? Not sure yet.

SOLIDS are collections of faces

#+BEGIN_SRC clojure
(ns stylo.struct
  (:require [ubergraph.core :as uber]))

(defn line-g
  [& points]
  (uber/graph (mapv #(conj [:curve] %) points)))

(defn face-g
  [& curves]
  (uber/graph (mapv #(conj [:surface] %) curves)))

(defn solid-g
  [& surfaces]
  (mapv #(conj [:solid] %) surfaces))

(defn box
  [l w h]
  (let [[la lb] [(/ l 2) (/ l -2)]
        [wa wb] [(/ w 2) (/ w -2)]
        [ha hb] [(/ h 2) (/ h -2)]
        [p1 p2 p3 p4] [[la wa ha] [la wb ha] [lb wb ha] [lb wa ha]]
        [p5 p6 p7 p8] [[la wa hb] [la wb hb] [lb wb hb] [lb wa hb]]
        [c1 c2 c3 c4] (map #(apply line-g %) (partition 2 1 [p1 p2 p3 p4 p1]))
        [c5 c6 c7 c8] (map #(apply line-g %) [[p1 p5] [p2 p6] [p3 p7] [p4 p8]])
        [c9 c10 c11 c12] (map #(apply line-g %) (partition 2 1 [p5 p6 p7 p8 p5]))
        faces (map #(apply face-g %) [[c1 c2 c3 c4]
                                      [c1 c5 c9 c6]
                                      [c2 c6 c10 c7] 
                                      [c3 c7 c11 c8] 
                                      [c4 c8 c12 c5] 
                                      [c9 c12 c11 c10]])]
    (apply solid-g faces)))

#+END_SRC

** ideas
*** implicit load
Build a mechanism to generate a namespace declaration based on the filename of the file being rendered.

Eg. 'ring-frame.md' -> (ns ring-frame.doc ..)

And always (:require [stylo.draw :refer :all])
The program will also look for existance of ring-frame.clj(s/c) and put a (load-file ..) in as well.

This eliminates the need for the user to specify ns at the top of the markdown file themselves.

*** abstractions
 The user of the library will generally expect to be 'working with sketches' and 'working with solids'. So, make them central to the workflows and library design.

 For 3D things, the abstraction might be 'solids'. It could be represented as a map or sequence of maps (nesting permitted). Solids need:
  - vertices
  - edges
  - faces
  - combinations of each

 For 2D things, the abstraction might be 'sketches'. It could be represented as a map or sequence of maps (nesting permitted). Sketches need:
  - vertices (2d)
  - edges (2d)
  - faces
  - combinations of each

 Since 2D and 3D have many overlapping concepts, it is hard to know where to separate things out. For example, curve/edge functions could work in both contexts, but 'cube' doesn't really make sense in a sketch context (unless you automatically allow projections, slices, etc.)

 There seems to also be a need for non-solid and non-sketch objects:
  - pts
  - guidelines
  - grids

 There are also non-geometric items:
  - constraints
  - labels, annotations
  - parameters
  - global state?
  - animations?
  - visibility
  - colours

*** debug visuals
 It might be useful to have a 'debug' dynamic variable that when true renders additional elements, such as dots, centerlines, gridlines, rotation lines to help visually debug drawings.

 The simplest idea:
 - when true, conj additional lines and dots to the output that drawing functions give. Probably want to separate that though

*** smarter rotate and positioning
 Have the code do more of the positioning work for me. Eg. clamp corners based on bounding boxes... 

 maybe even have a 'autofill' that fills up a specified area sequentially with provided items... this is almost like CSS flexbox, maybe?

*** updating when several files change
 Sometimes it's nice to define figure code in a separate .clj file. Currently, fswatch doesn't have any mechanism for watching other files that are relevant to the markdown... solve this probably by building a simple server instead of relying on the external fswatch program.

*** speed up document builds
 Learn core.async?
 Make my parser loader, etc. more efficient in general.

 Find a way to only update parts of the doc. that have actually changed?

*** fabric
 Create a 'piece' abstraction. This is a fabric piece taht the user creates with a set of pts and a fabric CSS class.

 (piece pts "FABRIC-A")

 The pts are the 'display' dimensions. Eg. a 3in square in a finished quilt is cut out of the raw fabric as a 3.5in sq. piece, because the seams are  0.25in. As a piece is added to the quilt, the 'seams' are 'consumed' as pieces sharing edges are sewn together.

 So,

 (sew piece-a piece-b [edge-of-a edge-of-b])


 Quilts are built up by sewing one part at a time.

 Perhaps I could create an abstraction that just takes a list of elmenets (just pieces and a coord). Then, I can 'partition' the list for different sub-steps.

 I could specify step numbers to define figures.

 Fig. 1 is just (take 1 quilt)
 Fig. 4 is (take N quilt)...
* style
Stylo uses garden.core/css to compile clojure data into css. The theme is ported from *mu* with a few base classes added for features of Stylo specifically.

** style-base
This is the base style set used in all themes.

*** ns
#+BEGIN_SRC clojure :tangle ./src/stylo/style/base.cljc
(ns stylo.style.base
  (:require [garden.core :refer [css]]
            [garden.stylesheet :refer [at-media]]
            [garden.units :as u]))

#+END_SRC

*** draw
These styles are used within the draw namespace.

#+BEGIN_SRC clojure :tangle ./src/stylo/style/base.cljc
(def draw
  [[:.ln {:stroke "#2e3440" :stroke-width (u/px 2)}]
   [:.ln-d {:stroke "#2e3440" 
            :stroke-width (u/px 2)
            :stroke-linecap "round"
            :stroke-dasharray "4, 5"}]
   [:.clr {:fill "none"}]
   [:.attn {:fill "rgb(234, 82, 111)"}]
   [:.attn-ln {:stroke "rgb(234, 82, 111)"
               :stroke-width (u/px 3)}]
   [:.face {:fill "#a3be8c"
           :fill-rule "evenodd"}]
   [:rect :line :path :polygon :polyline :circle {:vector-effect "non-scaling-stroke"}]])

#+END_SRC

*** tables
#+BEGIN_SRC clojure :tangle ./src/stylo/style/base.cljc
(def tables
  [[:table {:width "auto"}]
   [:th :td {:vertical-align "top"
             :padding (u/px 5)
             :border "1px solid #ddd"}]
   [:table [:ul {:list-style-type "none"
                  :padding-left (u/px 4)
                  :margin 0}]]
   [:table [:li:before {:content "▢ "}]]
   [:table [:p {:margin 0}]]])

#+END_SRC

*** figures
#+BEGIN_SRC clojure :tangle ./src/stylo/style/base.cljc
(def figures
  [[:.figure {:padding-left (u/px 7)}]
   [:.figure [:p {:font-size "smaller"
                  :font-style "italic"}]]])

#+END_SRC

*** code
#+BEGIN_SRC clojure :tangle ./src/stylo/style/base.cljc
(def code
  [[:code.block {:padding (u/px 8)
                 :background "#2e3440"
                 :color "#dedee9"
                 :white-space "pre-wrap"
                 :display "inline-block"
                 :width (u/percent 100)}]])

#+END_SRC

#+RESULTS[2342df20361e21aa93ed992c794f248f81cefa1d]: style-base-code
: #'stylo.style.base/code

*** hidden
#+BEGIN_SRC clojure :tangle ./src/stylo/style/base.cljc
(def hidden
  [[:.hidden {:display "none"}]])

#+END_SRC
*** pagebreak
#+BEGIN_SRC clojure :tangle ./src/stylo/style/base.cljc
(def pagebreak
  [(at-media {:print ""}
             [:.pagebreak {:page-break-after "always"}])])

#+END_SRC

*** build
#+BEGIN_SRC clojure :tangle ./src/stylo/style/base.cljc
(def style
  (concat
   draw
   tables
   figures
   code
   hidden
   pagebreak))

(def style-str
  (css style))

#+END_SRC

** theme-mu
[[https://github.com/BafS/mu][mu]]
The mu theme is nice for documentation. I like it  for it's clean look and simple css.

*** ns
#+BEGIN_SRC clojure :tangle ./src/stylo/style/mu.cljc
(ns stylo.style.mu
  (:require [garden.core :refer [css]]
            [garden.stylesheet :refer [at-media]]
            [garden.units :as u]
            [stylo.style.base :as base]))

#+END_SRC

*** attribution
The license and attribution are in a comment header at the top of the original code, and shall be respected.

#+BEGIN_SRC clojure :tangle ./src/stylo/style/mu.cljc
(def license-str ""
"
/*!
MIT License

Copyright (c) 2016 Fabien Sa

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the \"Software\"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

")

(def attrib-str "" 
"
/*
| The mu framework v0.3.1
| BafS 2016-2018
*/

")

#+END_SRC

*** fonts
The theme has embedded fonts, which is perfect as the final rendered document will be fully usable offline. But, since the data is embedded, we want to import it from a file so that we're not cluttering up this file.

#+BEGIN_SRC clojure :tangle ./src/stylo/style/mu.cljc
(def fonts
  [[:* :*:after :*:before {:box-sizing "border-box"}]
   [:body {:font "18px/1.6 Georgia, \"Times New Roman\", Times, serif"}]
   [:table :input {:font-size (u/px 16)}]
   [:button :select {:font-size (u/px 14)}]
   [:h1 :h2 :h3 :h4 :h5 :h6 {:font-family "\"Helvetica Neue\", Helvetica, Arial, sans-serif"
                             :line-height 1.2}]])

#+END_SRC

*** page-setup
The page setup is most of the theme.

#+BEGIN_SRC clojure :tangle ./src/stylo/style/mu.cljc
(def page-setup
  [[:body {:margin [[(u/px 40) "auto"]]
           :max-width (u/px 760)
           :color "#444"
           :padding [[0 (u/px 20)]]}]
   [:a {:color "#07c"
        :text-decoration "none"}]
   [:a:hover {:color "#059"
              :text-decoration "underline"}]
   [:hr {:border 0
         :margin [[(u/px 25) 0]]}]])

#+END_SRC
*** tables
The table styling

#+BEGIN_SRC clojure :tangle ./src/stylo/style/mu.cljc
(def tables
  [[:table {:border-spacing 0
            :border-collapse "collapse"
            :text-align "left"
            :padding-bottom (u/px 25)}]
   [:td :th {:padding (u/px 5)
             :vertical-align "bottom"}]
   [:td :th :hr {:border-bottom [[(u/px 1) "solid" "#ddd"]]}]])

#+END_SRC

*** blocks
Block element styles

#+BEGIN_SRC clojure :tangle ./src/stylo/style/mu.cljc
(def blocks
  [[:pre {:padding (u/px 8)
          :white-space "pre-wrap"}]])

#+END_SRC

*** inputs
The styles for input type elements

#+BEGIN_SRC clojure :tangle ./src/stylo/style/mu.cljc
(def inputs
  [[:button :select {:background "#ddd"
                     :border 0
                     :padding [[(u/px 9) (u/px 20)]]}]
   [:input {:padding (u/px 5)
            :vertical-align "bottom"}]
   [:button:hover {:background "#eee"}]
   [:textarea {:border-color "#ccc"}]])

#+END_SRC

*** grid
The grid special classes

#+BEGIN_SRC clojure :tangle ./src/stylo/style/mu.cljc
(def grid
  [[:.row {:display "block"
           :width "auto"
           :min-height (u/px 1)}]
   [:.row:after {:content "\"\""
                 :display "table"
                 :clear "both"}]
   [:.row :.c {:float "left"}]
   [:table :.g2 :.g3 :.g3-2 :.m2 :.m3 :.m3-2 {:width (u/percent 100)}]
   
   [(at-media {:min-width (u/px 768)})
    [:.g2 {:width (u/percent 50)}]
    [:.m2 {:margin-left (u/percent 50)}]
    [:.g3 {:width (u/percent 33.33)}]
    [:.g3-2 {:width (u/percent 66.66)}]
    [:.m3 {:margin-left (u/percent 33.33)}]
    [:.m3-2 {:margin-left (u/percent 66.66)}]]])

#+END_SRC

*** build
Combine all of the definitions to build the style.

#+BEGIN_SRC clojure :tangle ./src/stylo/style/mu.cljc
(def style-str
  (str
   license-str
   attrib-str
   (css (concat
         fonts
         base/style
         page-setup
         tables
         blocks
         inputs
         grid))))

#+END_SRC
** alt-themes
I created .cljc files for a few other themes, which are in the following locations:

src/stylo/style/writ.cljc
src/stylo/style/latex.cljc
src/stylo/style/awsm.cljc

You can use them the same way mu is used in the stylo.builder library. They are cleared from the org file because I have not used them in practice.
* geom
** ns
#+BEGIN_SRC clojure :tangle ./src/stylo/geom.cljc
(ns stylo.geom)

#+END_SRC

With math-heavy work, it will become very important to handle floating point errors effectively.

It might be a good approach to compute symbolically. Look into computer algebra systems. Automatic differentiation (forward automatic).

It might be good to use a math library that already exists.

** maths
#+BEGIN_SRC clojure :tangle ./src/stylo/geom.cljc
(defn round
  [num places]
  (let [d (Math/pow 10 places)]
    (/ (Math/round (* num d)) d)))

(defn to-deg
  [rad]
  (* rad (/ 180 Math/PI)))

(defn to-rad
  [deg]
  (* deg (/ Math/PI 180)))

(defn sq
  [x]
  (* x x))

(defn clamp
  "clamps a value between lower bound and upper bound"
  [x lb ub]
  (cond
    (< x lb) lb
    (> x ub) ub
    :else x))

#+END_SRC

** bounding-box
#+BEGIN_SRC clojure :tangle ./src/stylo/geom.cljc
(defn bb-center
  [pts]
  (let [xs (map first pts)
        ys (map last pts)
        xmax (apply max xs)
        ymax (apply max ys)
        xmin (apply min xs)
        ymin (apply min ys)]
    [(+ (/ (- xmax xmin) 2.0) xmin)
     (+ (/ (- ymax ymin) 2.0) ymin)]))

#+END_SRC

** linear-algebra
#+BEGIN_SRC clojure :tangle ./src/stylo/geom.cljc
(defn normalize
  "find the unit vector of a given vector"
  [v]
  (let [m (Math/sqrt (reduce + (map * v v)))]
    (mapv / v (repeat m))))

(defn det
  [a b]
  (- (* (first a) (second b)) 
     (* (second a) (first b))))

(defn *d
  "calculates the dot product of two vectors"
  [a b]
  (reduce + (map * a b)))

(defn *c3d
  "calculates cross product of two 3d-vectors"
  [a b]
  (let [[a1 a2 a3] a
        [b1 b2 b3] b
        i (- (* a2 b3) (* a3 b2))
        j (- (* a3 b1) (* a1 b3))
        k (- (* a1 b2) (* a2 b1))]
    [i j k]))

#+END_SRC

** geometry
#+BEGIN_SRC clojure :tangle ./src/stylo/geom.cljc
(defn distance
  "Computes the distance between two points."
  [a b]
  (let [v (map - b a)
        v2 (apply + (map * v v))]
    (Math/sqrt v2)))

(defn perpendicular
  [[x y]]
  [(- y) x])

;; this is broken. the comparison of = with the cross product
;; will basically never be true... need to use a nearly? kind of fn

(defn pt-on-line?
  "determine if a point is on an infinitely extending line"
  [pt line]
  (let [[a b] line
        ap (mapv - a pt)
        bp (mapv - b pt)]
    (= (*c3d ap bp) [0 0 0])))

(defn radius-from-pts
  "compute the radius of an arc defined by 3 points"
  [p1 p2 p3]
  (when-not (pt-on-line? p1 [p2 p3])
    (let [a (distance p3 p2)
          b (distance p3 p1)
          c (distance p2 p1)
          s (/ (+ a b c) 2)
          sa ( - s a)
          sb ( - s b)
          sc ( - s c)
          rt (Math/sqrt (* s sa sb sc))
          R (/ (/ (* a b c) 4) rt)]
      R)))

;; https://math.stackexchange.com/a/1743505
(defn center-from-pts
  "compute the center point of an arc through 3 points"
  [p1 p2 p3]
  (when-not (pt-on-line? p1 [p2 p3])
    (let [u1 (mapv - p2 p1)
          u2 (mapv - p3 p1)
          w1 (*c3d (mapv - p3 p1) u1)
          u (normalize u1)
          w (normalize w1)
          v (*c3d w u)
          [bx by] [(*d u1 u) 0]
          [cx cy] [(*d u2 u) (*d u2 v)]
          h (/ (+ (sq (- cx (/ bx 2))) (sq cy) (- 0 (sq (/ bx 2)))) 
               (* 2 cy))]
      (mapv + p1 
            (mapv * (repeat (/ bx 2)) u) 
            (mapv * (repeat h) v)))))

#+END_SRC
* svg
This namespace has the SVG wrappers and nothing else. This means that the most useful elements listed here: [[https://developer.mozilla.org/en-US/docs/Web/SVG/Element]] are covered. More advanced SVG elements are currently not enabled, because the Stylo library focuses on creating simple diagrams and figures using the basics.

** ns
#+BEGIN_SRC clojure :tangle ./src/stylo/svg.cljc
(ns stylo.svg
  (:require [clojure.string :as s]
            [stylo.geom :as g]
            #?(:cljs 
               [cljs.reader :refer [read-string]])))

#+END_SRC

** svg-element
#+BEGIN_SRC clojure :tangle ./src/stylo/svg.cljc
(defn svg
  [[w h sc] & content]
  [:svg {:width w
         :height h
         :ViewBox (str "-1 -1 " w " " h)
         :xmlns "http://www.w3.org/2000/svg"}
   [:g {:transform (str "scale(" sc ")")} content]])

#+END_SRC

** string-helpers
*** misc
#+BEGIN_SRC clojure :tangle ./src/stylo/svg.cljc
(defn pt->str
  [pt]
  (apply str (interpose "," pt)))

(defn str->pt
  [s]
  (mapv read-string (s/split s #",")))

(defn points->str
  [pts]
  (apply str (interpose " " (map pt->str pts))))

(defn str->points
  [s]
  (mapv str->pt (s/split s #" ")))

(defn scale-str
  [sc]
  (str "scale(" sc ")"))

(defn translate-str
  [x y]
  (str "translate(" x " " y ")"))
 
(defn rotate-str
  ([r]
   (str "rotate(" r ")"))
  ([r [x y]]
   (str "rotate(" r " " x " " y ")")))

(defn hsl-str
  [h s l]
  (str "hsl(" h ", " s "%, " l "%)"))

#+END_SRC

*** path-helpers
#+BEGIN_SRC clojure :tangle ./src/stylo/svg.cljc
(defn closed-path-str
  [pts]
  (let [line-to #(str "L" (first %) " " (second %))
        move-to #(str "M" (first %) " " (second %))]
    (str 
     (move-to (first pts)) " "
     (apply str (interpose " " (map line-to (rest pts))))
     " Z")))

(defn path->pts
  [s]
  (as-> s s
    (s/replace s #"Z" "") ;; removes Z at end of path
    (s/split s #"\s") ;; split string at spaces
    (mapcat #(s/split % #"[A-Z]") s) ;;splits on alpha chars
    (filter #(not (= % "")) s)
    (map read-string s)
    (vec (map vec (partition 2 s)))))

#+END_SRC

*** transform-helpers
#+BEGIN_SRC clojure :tangle ./src/stylo/svg.cljc
(defn xf-kv->str
  [[k v]]
  (let [k (symbol k)
        v (apply list v)]
    (str k v)))

(defn str->xf-kv
  [s]
  (let [split (s/split s #"\(")
        key (keyword (first split))
        val (vec (read-string (str "(" (second split))))]
    [key val]))

(defn xf-map->str
  [m]
  (apply str (interpose "\n" (map xf-kv->str m))))

(defn str->xf-map
  [s]
  (if-let [s s]
    (into {} (map str->xf-kv (s/split-lines s)))
    {}))

#+END_SRC

** shapes
#+BEGIN_SRC clojure :tangle ./src/stylo/svg.cljc
(def svg-elements 
  #{:circle
    :ellipse
    :line
    :path
    :polygon
    :polyline
    :rect
    :text
    :g})

#?(:clj
   (defn check-svg-impl
     [multimethod]
     (println "Missing Implementation for:"
              (clojure.set/difference 
               svg-elements
               (into #{} (keys (methods multimethod)))))))

(defn circle
  [r]
  [:circle {:cx 0 :cy 0 :r r}])

(defn ellipse
  [rx ry]
  [:ellipse {:cx 0 :cy 0 :rx rx :ry ry}])

(defn line
  [[ax ay] [bx by]]
  [:line {:x1 ax :y1 ay :x2 bx :y2 by}])

(defn path
  [d]
  [:path {:d d
          :fill-rule "evenodd"}])

(defn closed-path
  [& paths]
  (let [paths (map closed-path-str paths)
        d (apply str (interpose "\n" paths))]
    (path d)))

(defn polygon
  [pts]
  [:polygon {:points (points->str pts)}])

(defn polyline
  [pts]
  [:polyline {:points (points->str pts)}])

(defn rect
  [w h]
  [:rect {:width w :height h :x (/ w -2.0) :y (/ h -2.0)}])

(defn text
  [text]
  (let [char-w 9.625
        char-h 10
        n-chars (count text)
        x (/ (* n-chars char-w) -2.0)
        y (/ char-h 2.0)]
    [:text {:x (/ (* n-chars char-w) -2.0)
            :y (/ char-h 2.0)
            :transform (xf-map->str {:rotate [0 (- x) (- y)]})
            :style {:font-family "monospace"
                    :font-size 16}} text]))

(defn g
  [& content]
  (into [:g {}] content))

#+END_SRC

** path
The path element has a small DSL to create compound curves. This includes the following (taken from [[https://www.w3schools.com/graphics/svg_path.asp]]):


    M = moveto
    L = lineto
    H = horizontal lineto
    V = vertical lineto
    C = curveto
    S = smooth curveto
    Q = quadratic Bézier curve
    T = smooth quadratic Bézier curveto
    A = elliptical Arc
    Z = closepath

*** arc
The arc command 

A rx ry x-axis-rotation large-arc-flag sweep-flag x y
 
a rx ry x-axis-rotation large-arc-flag sweep-flag dx dy

#+BEGIN_SRC clojure :tangle ./src/stylo/svg.cljc
(defn arc-str
  [rx ry x-deg lg sw x y]
  (apply str (interpose " " ["a" rx ry x-deg lg sw x y])))

;; arc drawing can be done in a few ways.
;; could implement different drawing methods w/ defmethod,
;; dispatch on :key OR on 'shape' of the args?

(defn circle-by-pts
  [p1 p2 p3]
  (let [[p1 p2 p3] (map #(conj % 0) [p1 p2 p3]) 
        r (g/radius-from-pts p1 p2 p3)
        c (drop-last (g/center-from-pts p1 p2 p3))]
    (color-element
     {:fill "none"
      :stroke "gray"
      :stroke-width 1}
     (g
      (translate c (circle r))
      (translate (drop-last p1) (circle 2))
      (translate (drop-last p2) (circle 2))
      (translate (drop-last p3) (circle 2))))))

(defn arc
  [p1 p2 p3]
  (let [[p1b p2b p3b] (map #(conj % 0) [p1 p2 p3]) 
        r (g/radius-from-pts p1b p2b p3b)
        m-str (apply str (interpose " " (cons "M" p1)))
        a-str (apply str (interpose " " (concat ["A" r r 0 0 0] p3)))]
    (path (apply str (interpose "\n" [m-str a-str])))))

#+END_SRC

** transforms
Translate works reasonably well. Currently there is a problem when translating :g tags if you don't already have a :translate key in the xf-map. I don't totally know why this is yet.

*** translate
**** translate-element
#+BEGIN_SRC clojure :tangle ./src/stylo/svg.cljc
(defmulti translate-element 
  (fn [_ element]
    (first element)))

(defmethod translate-element :circle
  [[x y] [k props]]
  (let [xf (str->xf-map (get props :transform "rotate(0 0 0)"))
        cx (:cx props)
        cy (:cy props)
        new-xf (-> xf
                   (assoc-in [:rotate 1] (+ x cx))
                   (assoc-in [:rotate 2] (+ y cy)))
        new-props (-> props
                      (assoc :transform (xf-map->str new-xf))
                      (update :cx + x)
                      (update :cy + y))]
    [k new-props]))

(defmethod translate-element :ellipse
  [[x y] [k props]]
  (let [xf (str->xf-map (get props :transform "rotate(0 0 0)"))
        cx (:cx props)
        cy (:cy props)
        new-xf (-> xf
                   (assoc-in [:rotate 1] (+ x cx))
                   (assoc-in [:rotate 2] (+ y cy)))
        new-props (-> props
                      (assoc :transform (xf-map->str new-xf))
                      (update :cx + x)
                      (update :cy + y))]
    [k new-props]))

(defmethod translate-element :line
  [[x y] [k props]]
  (let [new-props (-> props
                      (update :x1 + x)
                      (update :y1 + y)
                      (update :x2 + x)
                      (update :y2 + y))]
    [k new-props]))

(defmethod translate-element :path
  [[x y] [k props]]
  (let [paths (map path->pts (s/split-lines (:d props)))
        new-paths (for [path paths] 
                    (closed-path-str (map #(map + [x y] %) path)))
        new-props (assoc props :d (apply str (interpose "\n" new-paths)))]
    [k new-props]))

(defmethod translate-element :polygon
  [[x y] [k props]]
  (let [points (str->points (:points props))
        new-points (points->str (map #(map + [x y] %) points))
        new-props (assoc props :points new-points)]
    [k new-props]))

(defmethod translate-element :polyline
  [[x y] [k props]]
  (let [points (str->points (:points props))
        new-points (points->str (map #(map + [x y] %) points))
        new-props (assoc props :points new-points)]
    [k new-props]))

(defmethod translate-element :rect
  [[x y] [k props]]
  (let [xf (str->xf-map (get props :transform "rotate(0 0 0)"))
        cx (+ (:x props) (/ (:width props) 2.0))
        cy (+ (:y props) (/ (:height props) 2.0))
        new-xf (-> xf
                   (assoc-in [:rotate 1] (+ x cx))
                   (assoc-in [:rotate 2] (+ y cy)))
        new-props (-> props
                      (assoc :transform (xf-map->str new-xf))
                      (update :x + x)
                      (update :y + y))]
    [k new-props]))

(defmethod translate-element :text
  [[x y] [k props text]]
  (let [xf (str->xf-map (get props :transform "rotate(0 0 0)"))
        new-xf (-> xf
                   (update-in [:rotate 1] + x)
                   (update-in [:rotate 2] + y))
        new-props (-> props
                      (assoc :transform (xf-map->str new-xf))
                      (update :x + x)
                      (update :y + y))]
    [k new-props text]))

(defmethod translate-element :g
  [[x y] [k props & content]]
  (let [xf (str->xf-map (:transform props))
        new-xf (-> xf
                   (update :translate (fnil #(map + [x y] %) [0 0])))
        new-props (assoc props :transform (xf-map->str new-xf))]
    (into [k new-props] content)))

#+END_SRC

**** interface
#+BEGIN_SRC clojure :tangle ./src/stylo/svg.cljc
(defn element? [item]
  (svg-elements (first item)))

(defn translate
  [[x y] & elems]
  (let [elem (first elems)
        elems (rest elems)]
    (when elem
      (cond
        (and (element? elem) (= 0 (count elems)))
        (translate-element [x y] elem)
        
        (and (element? elem) (< 0 (count elems)))
        (concat
         [(translate-element [x y] elem)]
         [(translate [x y] elems)])
      
        :else
        (recur [x y] (concat elem elems))))))

;; this is the 'old' way.
(defn translate-g
  [[x y] & elems]
  (into [:g {:transform (translate-str x y)}] elems))

#+END_SRC
*** rotate
**** rotate-element
#+BEGIN_SRC clojure :tangle ./src/stylo/svg.cljc
(defn rotate-element-by-transform
  [deg [k props content]]
  (let [xf (str->xf-map (get props :transform "rotate(0 0 0)"))
        new-xf (-> xf
                   (update-in [:rotate 0] + deg))
        new-props (assoc props :transform (xf-map->str new-xf))]
    [k new-props content]))

(defn rotate-pt
  [deg [x y]]
  (let [c (Math/cos (g/to-rad deg))
        s (Math/sin (g/to-rad deg))]
    [(- (* x c) (* y s))
     (+ (* x s) (* y c))]))

(defmulti rotate-element
  (fn [_ element]
    (first element)))

(defmethod rotate-element :circle
  [deg [k props]]
  (rotate-element-by-transform deg [k props]))

(defmethod rotate-element :ellipse
  [deg [k props]]
  (rotate-element-by-transform deg [k props]))

(defn move-pt
  [mv pt]
  (mapv + pt mv))

(defn rotate-pt-around-center
  [deg center pt]
  (->> pt
       (move-pt (map - center))
       (rotate-pt deg)
       (move-pt center)))

(defmethod rotate-element :line
  [deg [k props]] 
  (let [pts [[(:x1 props) (:y1 props)] [(:x2 props) (:y2 props)]]
        center (g/bb-center pts)
        [[x1 y1] [x2 y2]]  (map (partial rotate-pt-around-center deg center) pts)
        new-props (-> props
                      (assoc :x1 x1)
                      (assoc :y1 y1)
                      (assoc :x2 x2)
                      (assoc :y2 y2))]
    [k new-props]))

(defmethod rotate-element :path
  [deg [k props]]
  (let [paths (map path->pts (s/split-lines (:d props)))
        center (g/bb-center (apply concat paths))
        new-paths (for [path paths] 
                    (closed-path-str 
                     (map 
                      (partial rotate-pt-around-center deg center) 
                      path)))
        new-props (assoc props :d (apply str (interpose "\n" new-paths)))]
    [k new-props]))

(defmethod rotate-element :polygon
  [deg [k props]]
  (let [points (str->points (:points props))
        center (g/bb-center points)
        new-points (points->str
                    (map 
                     (partial rotate-pt-around-center deg center)
                     points))
        new-props (assoc props :points new-points)]
    [k new-props]))

(defmethod rotate-element :polyline
  [deg [k props]]
  (let [points (str->points (:points props))
        center (g/bb-center points)
        new-points (points->str
                    (map 
                     (partial rotate-pt-around-center deg center)
                     points))
        new-props (assoc props :points new-points)]
    [k new-props]))

(defmethod rotate-element :rect
  [deg [k props]]
  (rotate-element-by-transform deg [k props]))

(defmethod rotate-element :text
  [deg [k props text]]
  (rotate-element-by-transform deg [k props text]))

(defmethod rotate-element :g
  [deg [k props & content]]
  (rotate-element-by-transform deg [k props content]))

#+END_SRC

**** interface
#+BEGIN_SRC clojure :tangle ./src/stylo/svg.cljc
(defn rotate
  [deg & elems]
  (let [elem (first elems)
        elems (rest elems)]
    (when elem
      (cond
        (and (element? elem) (= 0 (count elems)))
        (rotate-element deg elem)
        
        (and (element? elem) (< 0 (count elems)))
        (concat
         [(rotate-element deg elem)]
         [(rotate deg elems)])
        
        :else
        (recur deg (concat elem elems))))))

;; old approach
(defn rotate-g
  [r [x y] & elems]
  (into [:g {:transform (rotate-str r [x y])}] elems))

#+END_SRC

*** scale
SVG items are assumed to be positioned and moved around from their bounding box centers. This means that scaling an element will NOT move it's center position.

**** scale-element
#+BEGIN_SRC clojure :tangle ./src/stylo/svg.cljc
(defn scale-element-by-transform
  [[sx sy] [k props & content]]
  (let [xf (str->xf-map (:transform props))
        new-xf (-> xf
                   (update :scale (fnil #(map * [sx sy] %) [1 1])))
        new-props (assoc props :transform (xf-map->str new-xf))]
    [k new-props] content))

(defmulti scale-element 
  (fn [_ element]
    (first element)))

;; transforms are applied directly to the properties of shapes.
;; I have scale working the same way. One issue is that scaling a circle
;; turns it into an ellipse. This impl WILL change the shape to ellipse if non-uniform scaling is applied.

(defmethod scale-element :circle
  [[sx sy] [k props]]
  (let [circle? (= sx sy)
        r (:r props)
        new-props (if circle?
                    (assoc props :r (* r sx))
                    (-> props
                        (dissoc :r)
                        (assoc :rx (* sx r))
                        (assoc :ry (* sy r))))
        k (if circle? :circle :ellipse)]
    [k new-props]))

(defmethod scale-element :ellipse
  [[sx sy] [k props]]
  (let [new-props (-> props
                      (update :rx #(* sx %))
                      (update :ry #(* sy %)))]
    [k new-props]))

;; find bounding box center
;; translate bb-center to 0 0
;; scale all x y values by * [sx sy]
;; translate back to original bb-center

(defmethod scale-element :line
  [[sx sy] [k props]]
  (let [[cx cy] (g/bb-center [[(:x1 props) (:y1 props)]
                              [(:x2 props) (:y2 props)]])
        new-props (-> props
                      (update :x1 #(+ (* (- % cx) sx) cx))
                      (update :y1 #(+ (* (- % cy) sy) cy))
                      (update :x2 #(+ (* (- % cx) sx) cx))
                      (update :y2 #(+ (* (- % cy) sy) cy)))]
    [k new-props]))

(defn scale-pt-from-center
  [[cx cy] [sx sy] [x y]]
  [(+ (* (- x cx) sx) cx)
   (+ (* (- y cy) sy) cy)])

(defmethod scale-element :path
  [[sx sy] [k props]]
  (let [paths (map path->pts (s/split-lines (:d props)))
        center (g/bb-center (apply concat paths))
        new-paths (for [path paths] 
                    (closed-path-str 
                     (map 
                      (partial scale-pt-from-center center [sx sy])
                      path)))
        new-props (assoc props :d (apply str (interpose "\n" new-paths)))]
    [k new-props]))

(defmethod scale-element :polygon
  [[sx sy] [k props]]
  (let [points (str->points (:points props))
        center (g/bb-center points)
        new-points (points->str
                    (map 
                     (partial scale-pt-from-center center [sx sy])
                     points))
        new-props (assoc props :points new-points)]
    [k new-props]))

(defmethod scale-element :polyline
  [[sx sy] [k props]]
  (let [points (str->points (:points props))
        center (g/bb-center points)
        new-points (points->str
                    (map 
                     (partial scale-pt-from-center center [sx sy])
                     points))
        new-props (assoc props :points new-points)]
    [k new-props]))

(defmethod scale-element :rect
  [[sx sy] [k props]]
  (let [cx (+ (:x props) (/ (:width props) 2.0))
        cy (+ (:y props) (/ (:height props) 2.0))
        w (* sx (:width props))
        h (* sy (:height props))
        new-props (-> props
                      (assoc :width w)
                      (assoc :height h)
                      (update :x #(+ (* (- % cx) sx) cx))
                      (update :y #(+ (* (- % cy) sy) cy)))]
    [k new-props]))

(defmethod scale-element :text
  [[sx sy] [k props text]]
  (let [xf (str->xf-map (get props :transform "rotate(0 0 0)"))
        cx (get-in xf [:rotate 1])
        cy (get-in xf [:rotate 2])
        x (+ (* (- (:x props) cx) sx) cx)
        y (+ (* (- (:y props) cy) sy) cy)
        new-xf (-> xf
                   (assoc-in [:rotate 1] (- x))
                   (assoc-in [:rotate 2] (- y)))
        new-props (-> props
                      (assoc :transform (xf-map->str new-xf))
                      (assoc :x x)
                      (assoc :y y)
                      (update-in [:style :font-size] #(* % sx)))]
    [k new-props text]))

(defmethod scale-element :g
  [[sx sy] [k props & content]]
  (let [xf (str->xf-map (:transform props))
        new-xf (-> xf
                   (update :scale (fnil #(map * [sx sy] %) [1 1])))
        new-props (assoc props :transform (xf-map->str new-xf))]
    (into [k new-props] content)))
  
#+END_SRC

**** interface
#+BEGIN_SRC clojure :tangle ./src/stylo/svg.cljc
(defn scale
  [sc & elems]
  (let [[sx sy] (if (coll? sc) sc [sc sc])
        elem (first elems)
        elems (rest elems)]
    (when elem
      (cond
        (and (element? elem) (= 0 (count elems)))
        (scale-element [sx sy] elem)
        
        (and (element? elem) (< 0 (count elems)))
        (concat
         [(scale-element [sx sy] elem)]
         [(scale [sx sy] elems)])
        
        :else
        (recur [sx sy] (concat elem elems))))))

;; this is the old method
(defn scale-g
  [sc & elems]
  (into [:g {:transform (scale-str sc)}] elems))
#+END_SRC
*** style
Style transforms allow the user to change any attributes of svg elements that affect appearance. For instance, stroke color, stroke width, and fill.

To consider:
- classes/ids with style in a CSS file, how can user attach class/id tags?
- what is proper precedence for style data? should merge always put the 'newest' or keep the existing?

#+BEGIN_SRC clojure :tangle ./src/stylo/svg.cljc
(defn color-element
  [s-map [k props & content]]
  [k (merge props s-map) content])

#+END_SRC

** composites
#+BEGIN_SRC clojure :tangle ./src/stylo/svg.cljc
(defn arrow
  [a b]
  [:g {}
   [:marker {:id "head"
             :orient "auto"
             :markerWidth "0.5"
             :markerHeight "1"
             :refX "0.025"
             :refY "0.25"}
    [:path {:d "M0,0 V0.5 L0.25,0.25 Z"
            :fill "black"}]]
   [:polyline {:marker-end "url(#head)"
               :stroke "black"
               :stroke-width "2"
               :fill "rgba(0,0,0,0)"
               :points (points->str [a b])}]])

#+END_SRC
* draw
The draw namespace contains functions that produce svg elements.

The idea of the draw namespace is to wrap SVG functionality in Clojure functions.
2D/3D sketches/solids should be abstracted further from the SVG wrappers.

One thing that this ns currently handles poorly is that parametric functions, svg functions, and points functions are all mixed together. For example, (slope line) requires a parametric line as the input... but you wouldn't know that by looking.

** ns
#+BEGIN_SRC clojure :tangle ./src/stylo/draw.cljc
(ns stylo.draw
  (:require [clojure.spec.alpha :as s]
            [clojure.spec.test.alpha :as stest]
            [clojure.spec.gen.alpha :as gen]
            [clojure.test :as test]
            [stylo.geom :refer [round
                                to-deg
                                to-rad
                                bb-center
                                distance
                                perpendicular
                                normalize
                                det
                                ,*c3d]]
            [stylo.svg :refer [svg
                               circle
                               ellipse
                               line
                               path
                               closed-path
                               polygon
                               polyline
                               rect
                               text
                               scale
                               translate
                               rotate
                               arrow]]))

(defn label [t]
  (text t))

#+END_SRC

** containers
Containers are functions that wrap visual elements like 2D or 3D drawings.

#+BEGIN_SRC clojure :tangle ./src/stylo/draw.cljc
(defn figure
  ([descr content]
   (figure [500 250 25] descr content))

  ([[w h sc] descr & content]
   [:div.figure
    (svg [w h sc] content)
    [:p descr]]))

(defn quadrant-figure
  ([descr q1 q2 q3 q4]
   (quadrant-figure [720 720 25] descr q1 q2 q3 q4))
  
  ([[w h sc] descr q1 q2 q3 q4]
   (let [qw (/ w 2.0)
         qh (/ h 2.0)]
     [:div.figure 
      [:div 
       {:style {:display "flex"
                :flex-wrap "wrap"
                :width (str w "px")}}
       (svg [qw qh sc] q2)
       (svg [qw qh sc] q1)
       (svg [qw qh sc] q3)
       (svg [qw qh sc] q4)]
      [:p descr]])))

#+END_SRC

** parametric
Consider different representations of geometric objects:

 FREP: Functional Representation
 - uses signed distance functions (SDF)
 - SDFs take a coordinate [x y z] and return a distance

 BREP: Boundary Representation
 - uses parametric equations for edges and surfaces
 - PEs take parameters [t], [u v] and return a point
*** parametric-helpers
#+BEGIN_SRC clojure :tangle ./src/stylo/draw.cljc
;; this fn will tell you the parameter that correspondss to the distance along the line
(defn d->t
  [f d]
  (let [l (distance (f 0) (f 1))]
    (/ d l)))

;; fn will tell you the distance along the line that parameter's point is.
(defn t->d
  [f t]
  (distance (f 0) (f t)))

#+END_SRC
   
*** parametric-line
#+BEGIN_SRC clojure :tangle ./src/stylo/draw.cljc
(defn -line
  [a b]
  (fn [t]
    (cond
      (= (float t) 0.0) a
      (= (float t) 1.0) b
      :else
      (mapv + a (map * (map - b a) (repeat t))))))

(defn slope
  [f]
  (let [[x1 y1] (f 0)
        [x2 y2] (f 1)]
    (/ (- y2 y1) (- x2 x1))))

(defn parallel?
  [la lb]
  (= (slope la) (slope lb)))

(defn angle-between-lines
  [la lb]
  (if-not (parallel? la lb)  
    (let [m1 (slope la)
          m2 (slope lb)]
      (Math/atan (/ (- m1 m2) 
                    (+ 1 (* m1 m2)))))
    0))

#+END_SRC

*** sampling
Sampling in this context refers to setting up 'steps' through a parameterized fn and getting the result at each step. Eg. a sampled line could go from 0 1 t with steps of 0.1, for a total of 10 samples of positions along that line.

#+BEGIN_SRC clojure :tangle ./src/stylo/draw.cljc
(defn sample-1
  [f step]
  (let [t (range 0 1 step)]
    (map f t)))

(defn sample-2
  [f & steps]
  (for [u (range 0 1 (first steps))
        v (range 0 1 (second steps))]
    (f u v)))

(defn sample
  [f & steps]
  (let [n-params (count steps)]
    (if (= 1 n-params)
      (sample-1 f (first steps))
      (sample-2 f (first steps) (second steps)))))

;; slice only makes sense with 2+ dims? 
(defn slice
  [f u-step v-step]
  (for [u (range 0 1 u-step)]
    (for [v (range 0 1 v-step)]
      (f u v))))

(defn quad-path
  [u v u-step v-step]
  [[u v]
   [(+ u u-step) v]
   [(+ u u-step) (+ v v-step)]
   [u (+ v v-step)]])

;; quad-mesh only makes sense for surfaces (f u v)
(defn quad-mesh
  [f u-step v-step]
  (for [u (range 0 1 u-step)
        v (range 0 1 v-step)]
    (map #(apply f %) (quad-path u v u-step v-step))))

#+END_SRC

*** translate
#+BEGIN_SRC clojure :tangle ./src/stylo/draw.cljc
(defn translate-p
  [pts [mx my mz]]
  (map #(map + % [mx my mz]) pts))
#+END_SRC

It makes sense to have a higher-order function version of translate. This keeps the representation as FREP/BREP for as long as possible, keeping things small and concise. The idea is you can build up complex higher order functions to fully describe a part or assembly and sample it late (eg. only 'call' the function in a rendering method.)

To wrap both brep surfaces (f u v) and curves (f t), I currently am using & params to allow any number of params in the translate function.

I suspect there is a more effective approach, perhaps using a defmacro? Or some other quote/unqote approach that still uses defn.

#+BEGIN_SRC clojure :tangle ./src/stylo/draw.cljc
(defn brep-translate
  [f [mx my mz]]
  (fn [& params]
    (mapv + (apply f params) [mx my mz]))) 

#+END_SRC

*** rotate
#+BEGIN_SRC clojure :tangle ./src/stylo/draw.cljc
(defn sin-cos [theta]
  "give the results of sin and cos of theta(degrees) as [s c]"
  [(Math/sin (Math/toRadians theta)) 
   (Math/cos (Math/toRadians theta))])

(defn- rotate-pt-helper
  [[a b] theta]
  (let [[s-t c-t] (sin-cos theta)]
    [(- (* a c-t) (* b s-t))
     (+ (* b c-t) (* a s-t))]))

(defn rotate-pt
  [pt axis theta]
  (let [[x y z] pt]
    (cond
      (= axis :x) (into [x] (rotate-pt-helper [y z] theta))
      (= axis :y) (apply #(into [] [%2 y %1]) (rotate-pt-helper [z x] theta))
      (= axis :z) (into (rotate-pt-helper [x y] theta) [z]))))

(s/fdef rotate-pt
  :args (s/cat :pt ::pt3d :axis ::axis :theta number?)
  :ret  ::pt)

(defn rotate-about-axis
  [pts axis theta]
  (map #(rotate-pt % axis theta) pts))

(defn rotate-euler
  [pts [th-x th-y th-z]]
  (-> pts
    (rotate-about-axis :z th-z)
    (rotate-about-axis :y th-y)
    (rotate-about-axis :x th-x)))

(def isometric-euler-angles [30 45 0])

#+END_SRC

This is a higher-order function approach to rotate.
#+BEGIN_SRC clojure :tangle ./src/stylo/draw.cljc
(defn brep-rotate
  [f [th-x th-y th-z]]
  (fn [& params]
    (-> (apply f params)
        (rotate-pt :z th-z)
        (rotate-pt :y th-y)
        (rotate-pt :x th-x))))

#+END_SRC

*** circle
#+BEGIN_SRC clojure :tangle ./src/stylo/draw.cljc
(defn -circle
  [r]
  (fn [t]
    (let [t (* 2 Math/PI t)
          x (* r (Math/cos t))
          y (* r (Math/sin t))]
      [x y 0])))

#+END_SRC
*** ellipse
#+BEGIN_SRC clojure :tangle ./src/stylo/draw.cljc
(defn -ellipse
  [rx ry]
  (fn [t]
    (let [t (* 2 Math/PI t)
          x (* rx (Math/cos t))
          y (* ry (Math/sin t))]
      [x y])))

#+END_SRC

*** sphere
Following is an example of FREP and BREP functions for a sphere. I have some idea functions for tying both reps together into a single function.

The potential challenges will arise with boolean CSG operations (union, difference, intersection) as they are quite easy with FREP, but quite difficult with BREP.

The BREPs for compound shapes could easily diverge in data structure from FREP... for example, a box in BREP might be defined by having a group of parameterized faces which need to be handled in some appropriate manner.

The sphere is a bit simplistic because the BREP and FREP both map cleanly onto one another, but it is not a guarantee that every shape you might want to build has such properties.

#+BEGIN_SRC clojure :tangle ./src/stylo/draw.cljc
;; Functional Representation
;; SDF signed distance functions

(defn frep-sphere [r]
  (fn [[x y z]]
    (+ (* x x) (* y y) (* z z) (- (* r r)))))

;; Boundary Representation
(defn brep-sphere
  [r]
  (fn [u v]
    (let [[u v] (map #(* 2 Math/PI %) [u v])
          x (* r (Math/sin u) (Math/cos v))
          y (* r (Math/sin u) (Math/sin v))
          z (* r (Math/cos u))]
      [x y z])))

(defn sphere-idea-1
  [r]
  {:frep (frep-sphere r)
   :brep (brep-sphere r)})

(defn sphere-idea-2
  [r]
  (let [frep (frep-sphere r)
        brep (brep-sphere r)]
    (fn
      ([x y z] (frep x y z))
      ([u v] (brep u v)))))

#+END_SRC

** offset
An implementation of polygon path offsetting.

#+BEGIN_SRC clojure :tangle ./src/stylo/draw.cljc
;; this should be improved
;; currently can cause divide by zero issues

(defn line-intersection
  [[a b] [c d]]
  (let [[ax ay] a
        [bx by] b
        [cx cy] c
        [dx dy] d
        xdiff [(- ax bx) (- cx dx)]
        ydiff [(- ay by) (- cy dy)]
        div (det xdiff ydiff)
        d [(det a b) (det c d)]
        x (/ (det d xdiff) div)
        y (/ (det d ydiff) div)]
    [x y]))

(defn offset-edge
  [[a b] d]
  (let [p (perpendicular (mapv - b a))
        pd (map * (normalize p) (repeat (- d)))
        xa (mapv + a pd)
        xb (mapv + b pd)]
    [xa xb]))

(defn cycle-pairs
  [pts]
  (let [n (count pts)]
    (vec (take n (partition 2 1 (cycle pts))))))

(defn every-other
  [v]
  (let [n (count v)]
    (map #(get v %) (filter even? (range n)))))

(defn wrap-list-once
  [s]
  (conj (drop-last s) (last s)))

(defn offset
  [pts d]
  (let [edges (cycle-pairs pts)
        opts (mapcat #(offset-edge % d) edges)
        oedges (every-other (cycle-pairs opts))
        edge-pairs (cycle-pairs oedges)]
    (wrap-list-once (map #(apply line-intersection %) edge-pairs))))

#+END_SRC

** dimensions-2d
#+BEGIN_SRC clojure :tangle ./src/stylo/draw.cljc
(defn dimension
  [a b]
  (let [text (str (round (distance a b) 3))
        label-offset (* 0.225 (count text))
        label-angle (to-deg (angle-between-lines (-line a b) (-line [0 0] [1 0])))
        [ao bo] (offset-edge [a b] 2)
        mid (bb-center [ao bo])
        arw-a (-line mid ao)
        arw-b (-line mid bo)
        arw-t (- 1 (d->t arw-a 0.5))
        mid-t (d->t arw-a (* 1.75 label-offset))
        la (-line a ao)
        lb (-line b bo)
        [lat1 lat2] (map (partial d->t la) [0.5 2.5])
        [lbt1 lbt2] (map (partial d->t lb) [0.5 2.5])]
    (list
     (arrow (arw-a mid-t) (arw-a arw-t))
     (arrow (arw-b mid-t) (arw-b arw-t))
     (line (la lat1) (la lat2))
     (line (lb lbt1) (lb lbt2))
     (translate (map - mid [label-offset 0]) (rotate label-angle [label-offset 0] (scale 1.5 (label text)))))))

#+END_SRC

** 3d
*** renderable-objects
Renderable objects are maps containing vertices, edges, and faces. Each entity can be assigned additional data like color.
#+BEGIN_SRC clojure :tangle ./src/stylo/draw.cljc
(def entity-defaults
  {:color "#2e3440"
   :fill "#a3be8c"})

(defn entity
  ([vl]
   (entity entity-defaults vl))
  
  ([attr-map vl]
   {:val vl
    :attrs (merge entity-defaults attr-map)}))

#+END_SRC

*** extrude
The extrude function will work on XY-plane shapes. So, a list of nodes and edges where nodes are [x y].

Then, to extrude, take a height value, and all nodes are transformed with appropriate Z values.

For the easiest implementation, assume extrusion always happens from z=0 to z=h

All I have to do is copy the nodes, attach z 0 to one 'set' and z h to the other.

The extrude-pt ignores any existing Z values.
This is equivalent to 'projecting' the given pt onto the XY plane (sets Z to zero), and extruding from there.

EXTRUDE needs to add edges and faces. The extrude- fn currently only changes nodes, which will break the edges.

I can either update the edge indices (and add new edges) 

OR

---> Add the new nodes AFTER existing nodes (don't interleave), then no indices have to change, only new edges (and faces) are appended onto their appropriate lists.



#+BEGIN_SRC clojure :tangle ./src/stylo/draw.cljc
(defn polygon-2d
  "creates a closed 2d polygon tracing the list of points"
  [pts]
  (let [edges (map vec (partition 2 1 (concat 
                                       (range (count pts))
                                       [0])))]
    {:nodes (map entity pts)
     :edges (map entity edges) 
     :faces (list (entity (vec (range (count edges)))))}))

#+END_SRC

*** regular-polygon
#+BEGIN_SRC clojure :tangle ./src/stylo/draw.cljc
(defn regular-polygon-pts
  [r n]
  (let [angle (* 2 Math/PI (/ 1 n))]
    (for [step (range n)]
      [(* r (Math/cos (* step angle)))
       (* r (Math/sin (* step angle)))])))

(defn regular-polygon
  [r n]
  (polygon-2d (regular-polygon-pts r n)))

#+END_SRC

**** notes on vertical faces
This seems hacky, maybe I should entirely rethink how I store objects. However, the make-vert-face function DOES work with the current approach.

What it does is take advantage of the node/edge order when an extrude- fn runs.

We know that the sketch's original edges make up the first n edges, where N is the count of the edges in the sketch.

We know that (range 0 n) indices always point to the original edges.
We know that (because of how extrude- works) (range (inc n) (* 2 n)) is the set of edges making up the top plane
We know that the remaining indices (range (* 2 n) (* 3 n)) are the vertical edges.

We also know that extruding a polygon will always result in rectangular faces parallel to the extrude direction (assumed to be Z).

Using these facts, we can directly build the face by doing arithmetic on indices.

We pass the 'starting' idx, which will always be in (range 0 n) and just do the weird math in the fn.

The math was taken from diagrams that I sketched for myself. 

NOTE: this is probably a dumb way of doing things. Need to research better approaches.

#+BEGIN_SRC clojure :tangle ./src/stylo/draw.cljc
(defn make-vert-face
  [sk idx]
  (let [n (count (:edges sk))
        indices (vec (take (* 2 n) (cycle (range (* 2 n) (* 3 n)))))]
    [idx (get indices (inc idx)) (+ n idx) (get indices idx)]))

(defn extrude-
  [sk h]
  (let [nodes (map :val (:nodes sk))
        bnodes (map #(conj % 0) nodes)
        tnodes (map #(conj % h) nodes)
        xnodes (concat bnodes tnodes)

        nedges (count (:edges sk))
        bidx (concat (range nedges) [0])
        tidx (concat (range nedges (* 2 nedges)) [nedges])
        bedges (map :val (:edges sk))
        tedges (map vec (partition 2 1 tidx))
        medges (map vec (partition 2 (interleave bidx tidx)))
        xedges (concat bedges tedges medges)

        bfaces (map :val (:faces sk))
        mfaces (map #(make-vert-face sk %) (range (count nodes)))
        tfaces (list (vec (drop-last tidx)))
        xfaces (concat bfaces mfaces tfaces)]
    (-> sk
        (assoc :nodes (map entity xnodes))
        (assoc :edges (drop-last (map entity xedges)))
        (assoc :faces (map entity xfaces)))))

#+END_SRC

*** join
Like union, join takes two solids and merges them into one solid. Unlike union, join does NOT calculate intersections, trims, extensions, etc. It is a 'dumb union'.

As such, this is just a starting point, not a fully useful function.

#+BEGIN_SRC clojure :tangle ./src/stylo/draw.cljc
(defn shift-indices
  [entity shift-val]
  (let [shifter (fn [v]
                  (mapv #(+ shift-val %) v))]
    (update entity :val shifter)))

(defn join-two
  [a b]
  (let [anodes (:nodes a)
        aedges (:edges a)
        afaces (:faces a)
        bnodes (:nodes b)
        bedges (map #(shift-indices % (count anodes)) (:edges b))
        bfaces (map #(shift-indices % (count aedges)) (:faces b))
        unodes (concat anodes bnodes)
        uedges (concat aedges bedges)
        ufaces (concat afaces bfaces)]
    {:nodes unodes
     :edges uedges
     :faces ufaces}))

(defn join
  [& solids]
  (reduce join-two solids))

#+END_SRC

*** transforms
#+BEGIN_SRC clojure :tangle ./src/stylo/draw.cljc
(defn scl [theta]
  [(Math/sin (Math/toRadians theta)) (Math/cos (Math/toRadians theta))])

(defn -rot-pt
  [[a b] theta]
  (let [[s-t c-t] (scl theta)]
    [(- (* a c-t) (* b s-t))
     (+ (* b c-t) (* a s-t))]))

(defn rot-pt
  [axis theta [x y z]]
  (cond
   (= axis :x) (into [x] (-rot-pt [y z] theta))
   (= axis :y) (apply #(into [] [%2 y %1]) (-rot-pt [z x] theta))
   (= axis :z) (into (-rot-pt [x y] theta) [z])))

(defn -rot
  [ro axis theta]
  (let [nodes (map :val (:nodes ro))
        rnodes (mapv (partial rot-pt axis theta) nodes)]
    (assoc ro :nodes (mapv entity rnodes))))

(defn rot-
  [ro [th-x th-y th-z]]
  (-> ro
    (-rot :z th-z)
    (-rot :y th-y)
    (-rot :x th-x)))

(defn mv-pt
  [delta pt]
  (mapv + delta pt))

(defn mv-
  [ro delta]
  (let [nodes (map :val (:nodes ro))
        rnodes (mapv (partial mv-pt delta) nodes)]
    (assoc ro :nodes (mapv entity rnodes))))

#+END_SRC

*** sketches
**** changes to data structure ideas
Currently, 'edges' is just a list of lines. This doesn't provide enough detail up front to make poly-path faces (faces with holes). I need to have a list of closed paths.

- could make a function that searches the edge list for loops

- could add a :paths key that specifies loops at creation time instead.

#+BEGIN_SRC clojure :tangle ./src/stylo/draw.cljc
(defn sk->3d
  [sk]
  (let [nodes-2d (map :val (:nodes sk))
        nodes-3d (map #(entity (conj % 0)) nodes-2d)]
    (assoc sk :nodes nodes-3d)))

#+END_SRC

*** draw-edges
#+BEGIN_SRC clojure :tangle ./src/stylo/draw.cljc
(defn face->edges
  [ro face]
  (let [edges (mapv :val (:edges ro))]
    (mapv #(get edges %) face)))

(defn edge->nodes
  [ro edge]
  (let [nodes (mapv :val (:nodes ro))]
    (mapv #(get nodes %) edge)))

(defn face->nodes
  [ro face]
  (let [edges (face->edges ro face)]
    (into [] (distinct (mapcat (partial edge->nodes ro) edges)))))

(def iso-euler-angles [30 45 0])
(def origin-angle-adjust-a [90 0 0])
(def origin-angle-adjust-b [0 90 0])
(defn orient-iso
  [ro]
  (-> ro
      (rot- origin-angle-adjust-a)
      (rot- origin-angle-adjust-b)
      (rot- iso-euler-angles)))

(defn orient-top
  [ro]
  (rot- ro [0 0 270]))

(defn orient-front
  [ro]
  (rot- ro [90 0 270]))

(defn orient-right
  [ro]
  (rot- ro [90 0 0]))

(defn draw-edges
  ([ro]
   (draw-edges ro orient-iso))
  
  ([ro orientation]
   (let [ro (orientation ro)
         nodes (map :val (:nodes ro))
         edges (:edges ro)]
     (for [edge edges]
       (let [col (:color (:attrs edge))
             [n0 n1] (:val edge)
             [xa ya _] (nth nodes n0)
             [xb yb _] (nth nodes n1)]
         (path [[xa ya] [xb yb]]))))))

;; this was an older version of draw-edges
(defn obj?
  [item]
  (and (map? item)
       (and
        (contains? item :nodes)
        (contains? item :edges)
        (contains? item :faces))))

(defn get-nested-objects
  [ro]
  (filter seqable? ro))

(defn draw-edges-recursive
  [ro]
  (if (and (coll? ro) 
           (not (obj? ro)))
    (concat (map draw-edges-recursive ro))
    (draw-edges ro identity)))

#+END_SRC

*** cad-view
#+BEGIN_SRC clojure :tangle ./src/stylo/draw.cljc
(defn get-2d-pts
  [ro]
  (bb-center 
   (map #(into [] (take 2 %))
        (map :val (:nodes ro)))))

(defn get-move-coords
  [[w h sc] ro]
  (let [dc (get-2d-pts ro)
        wc (mapv #(* (/ % 2.0) sc) [w h])]
    (mapv - wc dc)))

(defn center-view
  [[w h sc] ro]
  (let [coords (get-move-coords [w h (/ 1 sc)] ro)]
    (translate coords (draw-edges-recursive ro))))

;; iso, top, front, right
(defn cad-view
  [[w h sc] descr ro]
  (let [qw (/ w 2.0)
        qh (/ h 2.0)]
    (quadrant-figure 
     [w h sc] 
     descr
     (center-view [qw qh sc] (orient-iso ro))
     (center-view [qw qh sc] (orient-top ro))
     (center-view [qw qh sc] (orient-front ro))
     (center-view [qw qh sc] (orient-right ro)))))

#+END_SRC
* builder
*** repl-load
#+BEGIN_SRC clojure
(load-file "src/stylo/builder.cljc")
(ns stylo.builder)

#+END_SRC
** ns
#+begin_src clojure :tangle ./src/stylo/builder.cljc
(ns stylo.builder
  (:require [clojure.string :as s]
            [hiccup.core :refer [h html]]
            [hiccup.def :refer [defelem]]
            [hiccup.page :as page]
            [hiccup.form :as form]
            [hiccup.element :as elem]
            [stylo.style.mu :as mu]
            [instaparse.core :as insta]))

#+end_src
** parser
The base parser is derived in part from the following code:
https://github.com/danneu/klobbdown/blob/master/src/klobbdown/parse.clj

Things that don't work properly:
- indented bullet lists
- nested bullet lists
- '---' should be horizontal separator, doesn't work
- ordered lists don't work (numerical or alpha)
- '[' and ']' don't work inside a paragraph
- '{' and '}' don't work inside a paragraph
- embedded html renders, but does have extra paragraphs being inserted. it seems that newlines in html snippets are causing empty p tags to exist


- change names in the grammar to full-length names so that it's easier to read. eg. hd = heading, str = strong para = paragraph, etc.
- change the keys in the transform map to match the name changes.

- '-' and '!' sort of work. Both NEED a full line between anything preceding. Need to fix this to allow single newline paragraph separation.


#+BEGIN_SRC clojure :tangle ./src/stylo/builder.cljc
;; old kinda working unordered lists.
;; ul = ul-i+ <bl>
;; ul-i = <'- '> #'.+' <nl>?

(def -md ""
"<root> = (hd |
           ul |
           ol |
           code |
           anc |
           img |
           tb |
           ex |
           kl |
           kl-hidden |
           para)+

para = (i-code |
        anc |
        str |
        em |
        para-t)+ <nl> (<nl>+)?

<para-t> = #'[^`\\n*#{}\\[\\]]+'

hd = #'^#{1,} .+' <nl>? <bl>?

str = <'**'> str-t <'**'> 
<str-t> = #'[^\\*\\*]+'

em = <'*'> em-t <'*'>
<em-t> = #'[^\\*]+'

ul = ul-i+ <nl>
ul-i = <nl> <'- '> para-t <nl>?

ol = ol-i+ <bl>
ol-i = <ol-i-token> #'.*' <nl>?
ol-i-token = #'[0-9]+\\. '

i-code = <'`'> #'[^`]+' <'`'>
code = <'~~~'> lang? <nl> code-t <'\n~~~'> <bl>
lang = <' '> #'[a-zA-Z]+'
code-t = #'[^\\n~~~]+'

anc = a-anc | t-anc
<a-anc> = <'<'> url <'>'>
<t-anc> = <'['> text <']'> <'('> url <')'>
<text> = #'[^]]+'
<url> = #'[^>)]+'

img = <nl>? <'!'>
      <'['> alt <']'>
      <'('> path title? <')'> <nl> (<nl>+)?

<alt> = #'[^]]+'
<path> = #'[^) ]+'
<title> = <spcs> #'[^)]+'

spc = ' '
spcs = spc+
bl = #'\n\n'
nl = #'\n' ")

#+END_SRC

*** parser-test
#+BEGIN_SRC clojure :tangle ./test/stylo/builder_test.cljc
(deftest parser
"")
#+END_SRC

** extensions
#+BEGIN_SRC clojure :tangle ./src/stylo/builder.cljc
;; doc extensions
(defn gen-ext-str
  [tag]
  (let [main (str tag " = <'{" tag "}'> <nl> " tag "-t <'{" tag "}'> <bl>\n") 
        inner (str "<" tag "-t> = #'([\\s\\S]*?)(?=(\\{" tag "\\}))'")]
    (str main inner)))

(def -ex (gen-ext-str "ex"))
(def -tb (gen-ext-str "tb"))
(def -kl (gen-ext-str "kl"))
(def -kl-hidden (gen-ext-str "kl-hidden"))

;; fix this transform. It doesn't work without a fn being run

(defn transform-ex
  [text]
  (let [results (read-string (str "[" (s/replace text #"\n" "") "]"))
        vals (map eval results)]
    (for [val vals]
      (when (not (var? val))
        [:div val]))))

(defn transform-kl
  [text]
  [:div.cm-container [:code.clj.block text]])

(defn transform-kl-hidden
  [text]
  [:div.hidden [:code.clj.block text]])

#+END_SRC

** transformers
#+BEGIN_SRC clojure :tangle ./src/stylo/builder.cljc
(declare ->hiccup)
(declare doc-parse)
;; Transformers ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn transform-anchor
  ([url] [:a {:href url} url])
  ([text url] [:a {:href url} text]))

(defn transform-emphasis
  [text]
  [:em text])

(defn transform-strong
  [text]
  [:strong text])

(defn transform-pre-code
  ([text] [:pre [:code text]])
  ([lang text] [:pre [:code text]]))

(defn transform-inline-code
  [text]
  [:code text])

(defn transform-image
  ([alt path] [:img {:src path :alt alt}])
  ([alt path title] [:img {:src path :alt alt :title title}]))

(defn transform-unordered-item
  [item]
  [:li item])

(defn transform-unordered-list
  [& items]
  (into [:ul] items))

(defn transform-ordered-item
  [item]
  [:li item])

(defn transform-ordered-list
  [& items]
  (into [:ol] items))

(defn transform-paragraph
  [& items]
  (into [:p] items))

(defn transform-heading
  [text]
  (let [octothorpes (first (s/split text #" "))
        text (s/trim (s/replace text #"#" ""))
        level (count octothorpes)
        tag (keyword (str "h" level))]
    [tag text]))

(defn transform-table
  [text]
  (let [seq (map #(s/split % #"\|") (s/split text #"\|\n"))
        body [:tbody
              (for [row (rest seq)]
                (into [:tr] (mapv #(conj [:td] (->hiccup (doc-parse (str (s/trim %) "\n\n")))) (rest row))))]
        head [:thead
                 (into [:tr]
                       (mapv #(conj [:th] (->hiccup (doc-parse (str (s/trim %) "\n\n")))) (rest (first seq))))]]
    (conj [:table] head body)))

#+END_SRC

** compiler
#+BEGIN_SRC clojure :tangle ./src/stylo/builder.cljc
(def doc-parse (insta/parser (str -md -tb -ex -kl -kl-hidden)))

(defn ->hiccup
  [tree]
  (let [transformations {:anc transform-anchor
                         :em transform-emphasis
                         :str transform-strong
                         :img transform-image
                         :tb transform-table
                         :ex transform-ex
                         :kl transform-kl
                         :kl-hidden transform-kl-hidden
                         :code transform-pre-code
                         :i-code transform-inline-code
                         :ul-i transform-unordered-item
                         :ul transform-unordered-list
                         :ol-i transform-ordered-item
                         :ol transform-ordered-list
                         :hd transform-heading
                         :para transform-paragraph}]
    (insta/transform transformations tree)))

(defn md->html
  "Parses markup into HTML."
  [markup]
  (html (->hiccup (doc-parse markup))))

(defn discern-title
  [markup]
  (let [t (first (s/split-lines markup))]
    (-> t
        (s/replace #"#" "")
        (s/trim))))

(defn md->page
  "compiles markup into a valid HTML5 string."
  [markup]
  (s/replace
   (hiccup.page/html5
    (concat [[:head
              [:meta {:charset "utf-8"}]
              [:title (discern-title markup)]
              [:style mu/style-str]]]
            [[:body [:main (->hiccup (doc-parse markup))]]]))
   #"><" ">\n<"))

(def klipse-settings "
window.klipse_settings = {
  selector: '.clj',
  codemirror_options_in: {
    lineWrapping: true,
    theme: 'nord',
  },
  codemirror_options_out: {
    lineWrapping: true,
    theme: 'nord',
  }
}
")

(def codemirror-style "
.cm-container {
  box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.4), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
  font-size: 10pt;
  margin: 0 auto;
  max-width: 520px;
}
.CodeMirror {
  border: none;
  padding: 8px;
}
")

(defn contains-klipse?
  [markup]
  (s/includes? markup "{kl}"))

(defn md->klipse
  [markup]
  (s/replace
   (hiccup.page/html5
    (concat [[:head
              [:meta {:charset "utf-8"}]
              [:title (discern-title markup)]
              [:style mu/style-str]]]
            [[:body
              [:main (->hiccup (doc-parse markup))]
              (when (contains-klipse? markup) (list
                [:link {:rel "stylesheet"
                        :type "text/css"
                        :href "https://unpkg.com/klipse@7.9.6/dist/codemirror.css"}]
                [:link {:rel "stylesheet"
                        :type "text/css"
                        :href "https://codemirror.net/theme/nord.css"}]
                [:style codemirror-style]
                [:script klipse-settings]
                [:script {:src "https://unpkg.com/klipse@7.9.6/dist/klipse_plugin.js"}]))]]))
   #"><" ">\n<"))

#+END_SRC

** main
The main fn is invoked via a terminal. The idea is to pipe markdown strings into stylo and recieve html out.

With more args sent to main, different actions can occur. For instance, if you pass in a string and file, it can compile the string to that file. If you give two filenames, it converts the one into the other. If you give only one file, it converts it to html or errors out on invalid markup file.

A watcher will be nice too, which can either be invoked with a flag to -main OR by calling a different alias in deps.edn. Either way, the watcher will watch a single file and start a server that reloads when only that file changes. This will allow you to quickly spawn a live-reload environment to author with.

#+BEGIN_SRC clojure :tangle ./src/stylo/builder.cljc
(defn get-name
  [fpath]
  (first (s/split (last (s/split fpath #"/")) #"\.")))

(defn get-path
  [fpath]
  (let [fname (last (s/split fpath #"/"))]
    (s/replace fpath fname "")))

(defn -main [fpath]
  (let [markup (slurp fpath)
        name (get-name fpath)
        opath (get-path fpath)
        fname (str name ".html")]
    (do 
      (spit (str opath fname) (md->klipse markup))
      (println (str "created: " fname)))))

#+END_SRC
* extensions
Extensions are currently saved into src/stylo/ext/ext_name.cljc

Extensions are used to add functionality to the library that is clearly separated fom the core. The *fabric* extension is a great example: It has clear use in the context of creating quilt patterns, but is not general enough to be necessary in the core library.

Fabric uses many functions from the *draw* namespace, but any new functionality is useful in the specific domain that the extension covers, which is quilt patterns in this case. For instance, the 'template' function uses polygon and offset, but creates a 'piece' that only really makes sense in quilts.

** fabric
The extension used for creating quilt patterns. I think eventually I will separate things out into a program called qpunk which can be used specifically for creating quilt patterns. Qpunk would then pull in stylo as a library.

*** ns
#+BEGIN_SRC clojure :tangle ./src/stylo/ext/fabric.cljc
(ns stylo.ext.fabric
  (:require [clojure.string :as s]
            [stylo.draw :as draw]
            [stylo.svg :as svg]))

#+END_SRC

*** styles
#+BEGIN_SRC clojure :tangle ./src/stylo/ext/fabric.cljc
(def fabric-styles
  [:style "
.ln{stroke:#2e3440;stroke-width:1.5;}
.ln-d{stroke:#2e3440;stroke-width:1.5;stroke-linecap:round;stroke-dasharray:4, 5;}
rect, line, path, polygon, polyline {vector-effect:non-scaling-stroke;}
.attn{fill:rgb(234,82,111);}
.clr{fill:rgba(0,0,0,0);}
"])

#+END_SRC

*** shapes
#+BEGIN_SRC clojure :tangle ./src/stylo/ext/fabric.cljc
(defn sq
  ([s]
   (sq s nil))
  ([s class]
   [:rect {:class ["ln" (if class class "clr")]
           :width s
           :height s}]))

(defn rct
  ([[x y]]
   (rct [x y] nil))
  ([[x y] class]
   [:rect {:class ["ln" (if class class "clr")]
           :width x
           :height y}]))

(defn hst
  ([s]
   (hst s nil))
  ([s class]
   [:polygon {:class ["ln" (if class class "clr")]
              :points (svg/pt-str [[0 s] [s 0] [0 0]])}]))

(defn hst-pts
  [s]
  [[0 0] [s 0] [0 s]])

(defn diamond
  "draw a diamond of width and height with width offset and height offset factors."
  ([[w h wof hof]]
   (diamond [w h wof hof] nil))
  ([[w h wof hof] class]
   (let [wod (* w wof)
         hod (* h hof)]
     [:polygon {:class ["ln" (if class class "clr")]
                :points (svg/pt-str [[wod 0]
                                 [w hod]
                                 [wod h]
                                 [0 hod]])}])))

(defn diamond-pts
  [x y y2]
  (let [x2 (/ x 2.0)]
    [[x2 0]
     [x y2]
     [x2 y]
     [0 y2]]))

#+END_SRC

*** tools
#+BEGIN_SRC clojure :tangle ./src/stylo/ext/fabric.cljc
(defn stack
  [elem n]
  (let [spc 0.185
        tfrms (map #(vector (* % spc) (* % spc)) (range n))]
    [:g {}
     (map 
      (fn [[x y]] [:g {:transform (svg/translate-str x y)} elem]) 
      tfrms)]))

(def scale-1-to-1 146)

(defn polygon-template
  [name pts]
  (list
   (svg/polygon pts)
   (svg/polygon (draw/offset pts 0.25))
   (svg/translate (draw/bb-center pts) (svg/label name))
   (map #(svg/translate % (svg/scale 0.25 (svg/dot [0 0]))) pts)))

(defn diamond-template
  [name w h hof]
  (let [pts (diamond-pts w h hof)
        half-w (/ w 2.0)]
    (concat
     (polygon-template name pts)
     (draw/ln-d [half-w 0] [half-w h]))))

(defn colourize-template
  [template colour]
  (assoc-in (second template) [1 :class] (str "ln " colour)))

(defn seamless-piece
  [template colour]
  (assoc-in (first template) [1 :class] (str "ln " colour)))

#+END_SRC

*** blueberry-method-snippet
This is used in every pattern, so it makes sense to pull it into its own function for easy re-use.

#+BEGIN_SRC clojure :tangle ./src/stylo/ext/fabric.cljc

(def bb-heading
  [:h2 
   [:img {:style "width:50px;padding-right:10px;display:inline;"
          :src "./berry.png"}] 
   "The Blueberry Method"])

(def bb-instructions
  [:ol
   [:li "Draw a diagonal line on the wrong side of 4 squares designated for the Blueberry."]
   [:li "Place a Blueberry square RST onto the corners that meet in the middle of 4 selected units. Sew on the diagonal lines. Press two towards the corner, and then press the opposite two away from the corner. This will help to nest the seams together when completing The Blueberry. Trim."]
   [:li "Sew the seams together and your Blueberry will be complete."]])

(defn bb-a
  [berry-b]
  (list
   (sq 1.25 berry-b)
   (draw/ln-d [-0.1 1.35] [1.35 -0.1])))

(defn bb-b
  [berry-b col]
  (list
   (sq 2.5 col)
   (draw/mv [1.25 1.25] (bb-a berry-b))))

(defn bb-c
  [berry-b col]
  (list
   (sq 2.5 col)
   (draw/mv [1.25 1.25] (bb-a berry-b))
   (draw/mv [1.4 1.4] (draw/rot 180 [0.625 0.625] (hst 1.25 "trim"))
            (draw/mv [0.075 0.075] (draw/rot 180 [0.55 0.55] (hst 0.95 berry-b))))))

(defn bb-d
  [berry-f col out?]
  (list
   (sq 2.5 col)
   (draw/mv [1.25 1.25] (draw/rot 180 [0.625 0.625] (hst 1.25 berry-f))
       (if out?
         [:g {:transform "scale(0.625)"} (draw/arw [-0.1 -0.1] [1.35 1.35])]
         [:g {:transform "scale(0.625)"} (draw/arw [1.35 1.35] [-0.1 -0.1])]))))

(defn bb-e
  [berry-f col]
  (list
   (sq 2 col)
   (draw/mv [1.25 1.25] (draw/rot 180 [0.375 0.375] (hst 0.75 berry-f)))))

(defn bb-method
  "Blueberry Method Snippet expecting strings of CSS classes for each colour in the diagram.

  berry-f is the front berry colour.
  berry-b is the back berry colour.
  a is top left square colour.
  b is top right square colour.
  c is bottom right square colour.
  d is bottom left square colour."
  [berry-f berry-b col-a col-b col-c col-d]
  [:div.bb-method
   bb-heading
   bb-instructions
   [:div {:class "figure"}
    (draw/svg [700 160 22.5]
         (draw/mv [0.1 1.25]
             (bb-a berry-b)
             (draw/mv [1.75    0] (draw/rot  90 [0.625 0.625] (bb-a berry-b)))
             (draw/mv [1.75 1.75] (draw/rot 180 [0.625 0.625] (bb-a berry-b)))
             (draw/mv [   0 1.75] (draw/rot 270 [0.625 0.625] (bb-a berry-b))))
         (draw/mv [0.5 5.375] (draw/label "mark on"))
         (draw/mv [0.175 6.25] (draw/label "wrong side"))
         
         (draw/mv [5 0]
             (bb-b berry-b col-a)
             (draw/mv [3 0] (draw/rot  90 [1.25 1.25] (bb-b berry-b col-b)))
             (draw/mv [3 3] (draw/rot 180 [1.25 1.25] (bb-b berry-b col-c)))
             (draw/mv [0 3] (draw/rot 270 [1.25 1.25] (bb-b berry-b col-d))))
         (draw/mv [5.825 6.25] (draw/label "sew diagonals"))
         
         (draw/mv [12.25 0]
             (bb-c berry-b col-a)
             (draw/mv [3 0] (draw/rot  90 [1.25 1.25] (bb-c berry-b col-b)))
             (draw/mv [3 3] (draw/rot 180 [1.25 1.25] (bb-c berry-b col-c)))
             (draw/mv [0 3] (draw/rot 270 [1.25 1.25] (bb-c berry-b col-d))))
         (draw/mv [14.625 6.25] (draw/label "trim"))
         
         (draw/mv [19.5 0]
             (bb-d berry-f col-a false)
             (draw/mv [3 0] (draw/rot  90 [1.25 1.25] (bb-d berry-f col-b true)))
             (draw/mv [3 3] (draw/rot 180 [1.25 1.25] (bb-d berry-f col-c false)))
             (draw/mv [0 3] (draw/rot 270 [1.25 1.25] (bb-d berry-f col-d true))))
         (draw/mv [21.625 6.25] (draw/label "press"))
         
         (draw/mv [26.75 0.5]
             (bb-e berry-f col-a)
             (draw/mv [2 0] (draw/rot  90 [1 1] (bb-e berry-f col-b)))
             (draw/mv [2 2] (draw/rot 180 [1 1] (bb-e berry-f col-c)))
             (draw/mv [0 2] (draw/rot 270 [1 1] (bb-e berry-f col-d))))
         (draw/mv [27.5 6.25] (draw/label "sew seams")))

    [:p "Blueberry Point Method"]]])

#+END_SRC
* critical-todo
- [] dimensions has divide by zero problem. fix this

- [] implement fix for dims displaying wrong with small dims (eg. 2in doesn't display cleanly)

- [] show the axes so I know what directions things are pointing

- [] redo svg element wrappers. make the fn names obviously ONLY for creating hiccup data to be compiled into an svg element.
  - [] very deliberately create a clean separation between SVG drawing and creating/transforming sketch and solid elements. In general, imagine a situation where you cannot render to SVG, but still want the ability to create and transform solids and sketches. Eg. if you want to render to webgl 3D context, or create an exporter.

- [] create a macro or smoother system for showing/creating parameter maps

- [] get rid of old 'renderable object' map idea (eg. what (regular-polygon emits is not well designed)
  - [] update extrude- fn to accept whatever new approach is used

- [] auto-dimension function

- [] fix: dimension fn is built in a 2D sense. Make dimensions 3d elements that can be displayed in all orientations

- [] figure should have auto-centering so that I don't have to mess around with (mv [0 1]) manually

- [] parameter-table fn should also show the s-expr to show how values are derived

- [] create proper structures/absractions for sketches (2D stuff)

- [] create proper structures/abstractions for solids (3D stuff)

- [] create tube fns taking in a xsection

- [] make chamfer/radius fn in both 2d and 3d

- [] make a weldment fn
  - [] weldments as lists of 3d lines and their x-sections
  - [] intersection calculations for cut shapes (eg. chamfering tubes butted together)


- [] make actual join/cut operations 
