* ;;
#+Title: stylo
#+SUBTITLE: document rendering library
#+AUTHOR: adam-james
#+STARTUP: overview
#+PROPERTY: header-args :cache yes :noweb yes :results none :mkdirp yes :padline yes :async
#+HTML_DOCTYPE: html5
#+OPTIONS: toc:2 num:nil html-style:nil html-postamble:nil html-preamble:nil html5-fancy:t

** deps.edn
I intend to have stylo work in both clj/cljs contexts. As such, I need both clojure and clojurescript dependencies.

Some additional notes about deps:

- hiccup is clj only, hench macchiato/hiccups, which seems to be a near 1-1 port of hiccup to cljs
  - might be worth finding an alternative to hiccup that works in both clj/cljs so that I don't have to write conditionals in my src files

- I don't yet know if spec.alpha works in clojurescript
  - if it does, there is not change needed
  - if it does not, I will need to write in such a way that I can still build to cljs contexts by excluding spec.
    - this may simply be an alias in deps.edn
    - might require wrapping spec defs in reader conditionals

- garden (the css compiling lib.) works in cljs

- instaparse also works in both clj and cljs

#+NAME: deps.edn
#+begin_src clojure :tangle ./deps.edn
{:paths
 ["src" "tests"]
 
 :deps 
 {org.clojure/clojure            {:mvn/version "1.10.1"}
  org.clojure/clojurescript      {:mvn/version "1.10.597"}
  org.clojure/test.check         {:mvn/version "0.9.0"}
  org.clojure/spec.alpha         {:mvn/version "0.2.187"}
  forge/forge                    {:local/root "../forge"}
  hiccup                         {:mvn/version "2.0.0-alpha2"}
  macchiato/hiccups              {:mvn/version "0.4.1"}
  garden                         {:mvn/version "1.3.9"}
  instaparse                     {:mvn/version "1.4.10"}
  ubergraph                      {:mvn/version "0.8.2"}}}

#+end_src

** utilities
*** watcher script
Currently this script is called ~stylo-watch~ and will only work from within the stylo project (since clj is not being passed any classpath information)

#+BEGIN_SRC bash
#!/bin/bash
ECHO "watching: " $1
cd ~/dev/stylo/ && fswatch $1 | xargs -n1 -I{} clj -m stylo.builder {}
#+END_SRC

I have a copy of ~stylo-watch~ in ~/usr/local/bin/~ so I can call stylo-watch as a command in my terminal.

It is very important to update that script or remove it when I have a production-ready method for watch/build.

*** build
 This code snippet will build an executable. It uses node.js and cljs only.

 #+begin_src clojure
 (require 'cljs.build.api)
 (cljs.build.api/build "src" {:optimizations :advanced :output-to "out/main.js"})

 (use '[clojure.java.shell :only [sh]])
 #_(sh "nexe -i out/main.js -o stylo.exe")

 #+end_src
* design
** goals
I want to blend CAD and documentation into one simple, powerful, useful, and open library. Stylo approaches this problem by assuming the document IS the design, including prose, interactice elements, and 2D/3D figures. Export into popular formats is a must.

** concept
This program takes a document and renders it.

The intent is to have a plaintext file format. Markdown and org files are good examples. These files will have a simple syntax which allows text and code. The user can use or create 'extensions' which allow for more specialized sections in the documents. For example, github flavoured markdown has a more advanced concept of tables than the original specification of markdown.

These extensions will each have their own DSL which can be used directly in the plaintext document.

Users can write their document, run the stylo program binary on their file, and expect to see an .html file which fully contains their rendered work.

The rendered document is 'standalone'. It is (ideally) a single file (all images, and interactive elements are embedded).

Any interactive components in the document are fully contained in the file so that no internet connection is required.

*** pragmatic

 - it should be optional to render documents with links to a ./resources/ folder containing images (no embedding) to keep files smaller
 - for interactive elements, it may be simpler to distribute/keep files small by rendering with cdn links to js plugins
   - if there is a 3D viewer using three.js or babylon.js, it might be a better approach to NOT include the entire js library in the document and instead use a script tag with a link to the cdn.

** workflow
- user creates a new document in their editor of choice
- at the top of the file, the user can list the extensions they wish to use (if no list is provided, sensible defaults exist in the core library already)
- user runs the stylo program from the terminal, passing in the file as an arg.
- a file watcher is spawned and the document is rendered to an html file, and the file opens in the user's default browser
- changes to the document are detected and the html file is re-rendered and the browser refreshed.
- when the user is finished, they have both the source document and the finished html file to distribute as they wish.

This setup allows users to edit documents however they want and still see their changes live in the browser. This is a really nice way to work allowing for incremental improvements to the document. This is similar to how Clojure has a really nice REPL allowing for progams to be built up in small pieces.
** structure
Use graphs for everything.
NODES are all geometric entities:
 - points
 - curves/lines
 - faces
 - solids

EDGES are the ways in which the entities are related:
 - points-begins->line<-ends-points
 - solid -> face -> curve -> pt

The NODES will contain the BREP and FREP functions as well as any other computationally useful data. For instance, face could have a :hole true key to 'hint' the renders.

Not every possible relationship needs to be built up front. For example, it might make sense to compute center points into the graph later on (eg. center of face is a point that has a relation TO the face not necessarily FROM the face.

Do EDGES have properties of their own? Not sure yet.

SOLIDS are collections of faces

#+BEGIN_SRC clojure
(ns stylo.struct
  (:require [ubergraph.core :as uber]))

(defn line-g
  [& points]
  (uber/graph (mapv #(conj [:curve] %) points)))

(defn face-g
  [& curves]
  (uber/graph (mapv #(conj [:surface] %) curves)))

(defn solid-g
  [& surfaces]
  (mapv #(conj [:solid] %) surfaces))

(defn box
  [l w h]
  (let [[la lb] [(/ l 2) (/ l -2)]
        [wa wb] [(/ w 2) (/ w -2)]
        [ha hb] [(/ h 2) (/ h -2)]
        [p1 p2 p3 p4] [[la wa ha] [la wb ha] [lb wb ha] [lb wa ha]]
        [p5 p6 p7 p8] [[la wa hb] [la wb hb] [lb wb hb] [lb wa hb]]
        [c1 c2 c3 c4] (map #(apply line-g %) (partition 2 1 [p1 p2 p3 p4 p1]))
        [c5 c6 c7 c8] (map #(apply line-g %) [[p1 p5] [p2 p6] [p3 p7] [p4 p8]])
        [c9 c10 c11 c12] (map #(apply line-g %) (partition 2 1 [p5 p6 p7 p8 p5]))
        faces (map #(apply face-g %) [[c1 c2 c3 c4]
                                      [c1 c5 c9 c6]
                                      [c2 c6 c10 c7] 
                                      [c3 c7 c11 c8] 
                                      [c4 c8 c12 c5] 
                                      [c9 c12 c11 c10]])]
    (apply solid-g faces)))

#+END_SRC

** ideas
*** implicit load
Build a mechanism to generate a namespace declaration based on the filename of the file being rendered.

Eg. 'ring-frame.md' -> (ns ring-frame.doc ..)

And always (:require [stylo.draw :refer :all])
The program will also look for existance of ring-frame.clj(s/c) and put a (load-file ..) in as well.

This eliminates the need for the user to specify ns at the top of the markdown file themselves.

*** abstractions
 The user of the library will generally expect to be 'working with sketches' and 'working with solids'. So, make them central to the workflows and library design.

 For 3D things, the abstraction might be 'solids'. It could be represented as a map or sequence of maps (nesting permitted). Solids need:
  - vertices
  - edges
  - faces
  - combinations of each

 For 2D things, the abstraction might be 'sketches'. It could be represented as a map or sequence of maps (nesting permitted). Sketches need:
  - vertices (2d)
  - edges (2d)
  - faces
  - combinations of each

 Since 2D and 3D have many overlapping concepts, it is hard to know where to separate things out. For example, curve/edge functions could work in both contexts, but 'cube' doesn't really make sense in a sketch context (unless you automatically allow projections, slices, etc.)

 There seems to also be a need for non-solid and non-sketch objects:
  - pts
  - guidelines
  - grids

 There are also non-geometric items:
  - constraints
  - labels, annotations
  - parameters
  - global state?
  - animations?
  - visibility
  - colours

*** debug visuals
 It might be useful to have a 'debug' dynamic variable that when true renders additional elements, such as dots, centerlines, gridlines, rotation lines to help visually debug drawings.

 The simplest idea:
 - when true, conj additional lines and dots to the output that drawing functions give. Probably want to separate that though

*** smarter rotate and positioning
 Have the code do more of the positioning work for me. Eg. clamp corners based on bounding boxes... 

 maybe even have a 'autofill' that fills up a specified area sequentially with provided items... this is almost like CSS flexbox, maybe?

*** updating when several files change
 Sometimes it's nice to define figure code in a separate .clj file. Currently, fswatch doesn't have any mechanism for watching other files that are relevant to the markdown... solve this probably by building a simple server instead of relying on the external fswatch program.

*** speed up document builds
 Learn core.async?
 Make my parser loader, etc. more efficient in general.

 Find a way to only update parts of the doc. that have actually changed?

*** fabric
 Create a 'piece' abstraction. This is a fabric piece taht the user creates with a set of pts and a fabric CSS class.

 (piece pts "FABRIC-A")

 The pts are the 'display' dimensions. Eg. a 3in square in a finished quilt is cut out of the raw fabric as a 3.5in sq. piece, because the seams are  0.25in. As a piece is added to the quilt, the 'seams' are 'consumed' as pieces sharing edges are sewn together.

 So,

 (sew piece-a piece-b [edge-of-a edge-of-b])


 Quilts are built up by sewing one part at a time.

 Perhaps I could create an abstraction that just takes a list of elmenets (just pieces and a coord). Then, I can 'partition' the list for different sub-steps.

 I could specify step numbers to define figures.

 Fig. 1 is just (take 1 quilt)
 Fig. 4 is (take N quilt)...
* notes/issues
- fix order issues. For example, style-element is in 'transforms', but is used prior by cubic-bezier function. Techincally, it's not needed, but is used for 'debug visuals'.
  - try to elminate excessive (declar fn) usage.

- come up with a smarter debug visuals method. perhaps a macro that injects style elements or something?

- study transducers, see if they can be used with paths?

- write a style-guide that I Must reference for naming things. I always mix short/long form and change how I refer to pts, paths, elements, etc. THis is confusing. I should standardize by writing a doc. (and of course following it!)
  - this might be best done with a clojure spec namespace.

- the draw namespace is a complete mess. total re-write is probably necessary.

- figure fn. explicitly requires fig-num. Build into the document compiler the ability to count figures? This would make it much better for rearranging figures during edits. YOu don't have to pay attention to figure numbers

- make a helper function 'string-with-spaces' or something like it and replace all of the (apply str (interpose " " []))... to clean up the code a bit.

- 3d-transform-proto has NO logic about transforming 2d things. It just takes a list of 3d points and rotates them about 0 0 0. Clean this up

- rename the -rot rot- rot-pt functions / see if you can optimize them a bit to make it more understandable.

- see if you can implement rotations via quaternions, or perhaps some other sensible approach. Euler is fine, but can confuse people. Maybe there's a better approach?

- it might be important to come up with a 'scene' and a 'camera' abstraction for 3d.

- parametric-grid will give different results at the 'end conditions' based on the nx ny args. This is related to the even divisibility of the steps? This is a problem that can results in gaps when mapping a grid over a parametric surface. Use the cylinder as a visual test. Eg. nx = 40 leaves a gap, nx = 30 does not, 25 does... etc.


- dwg-2d is a misnomer? OR I need to create it properly to display in 2D... dwg-3d doesn't exist yet, but probably should

- I don't know if it's a good idea to implement 3D shapes as 1-1 map of the SVG elements. This may be needlessly limiting.

- camera transform functions currently fail with 2d point sets. 
** critical-todo
- [] dimensions has divide by zero problem. fix this

- [] implement fix for dims displaying wrong with small dims (eg. 2in doesn't display cleanly)

- [] show the axes so I know what directions things are pointing

- [] redo svg element wrappers. make the fn names obviously ONLY for creating hiccup data to be compiled into an svg element.
  - [] very deliberately create a clean separation between SVG drawing and creating/transforming sketch and solid elements. In general, imagine a situation where you cannot render to SVG, but still want the ability to create and transform solids and sketches. Eg. if you want to render to webgl 3D context, or create an exporter.

- [] create a macro or smoother system for showing/creating parameter maps

- [] get rid of old 'renderable object' map idea (eg. what (regular-polygon emits is not well designed)
  - [] update extrude- fn to accept whatever new approach is used

- [] auto-dimension function

- [] fix: dimension fn is built in a 2D sense. Make dimensions 3d elements that can be displayed in all orientations

- [] figure should have auto-centering so that I don't have to mess around with (mv [0 1]) manually

- [] parameter-table fn should also show the s-expr to show how values are derived

- [] create proper structures/absractions for sketches (2D stuff)

- [] create proper structures/abstractions for solids (3D stuff)

- [] create tube fns taking in a xsection

- [] make chamfer/radius fn in both 2d and 3d

- [] make a weldment fn
  - [] weldments as lists of 3d lines and their x-sections
  - [] intersection calculations for cut shapes (eg. chamfering tubes butted together)


- [] make actual join/cut operations 
* style
Stylo uses garden.core/css to compile clojure data into css. The theme is ported from *mu* with a few base classes added for features of Stylo specifically.

** style-base
This is the base style set used in all themes.

*** ns
#+BEGIN_SRC clojure :tangle ./src/stylo/style/base.cljc
(ns stylo.style.base
  (:require [garden.core :refer [css]]
            [garden.stylesheet :refer [at-media]]
            [garden.units :as u]))

#+END_SRC

*** draw
These styles are used within the draw namespace.

#+BEGIN_SRC clojure :tangle ./src/stylo/style/base.cljc
(def draw
  [[:.ln {:stroke "#2e3440" :stroke-width (u/px 2)}]
   [:.ln-d {:stroke "#2e3440" 
            :stroke-width (u/px 2)
            :stroke-linecap "round"
            :stroke-dasharray "4, 5"}]
   [:.clr {:fill "none"}]
   [:.attn {:fill "rgb(234, 82, 111)"}]
   [:.attn-ln {:stroke "rgb(234, 82, 111)"
               :stroke-width (u/px 3)}]
   [:.face {:fill "#a3be8c"
           :fill-rule "evenodd"}]
   [:rect :line :path :polygon :polyline :circle {:vector-effect "non-scaling-stroke"}]])

#+END_SRC

*** tables
#+BEGIN_SRC clojure :tangle ./src/stylo/style/base.cljc
(def tables
  [[:table {:width "auto"}]
   [:th :td {:vertical-align "top"
             :padding (u/px 5)
             :border "1px solid #ddd"}]
   [:table [:ul {:list-style-type "none"
                  :padding-left (u/px 4)
                  :margin 0}]]
   [:table [:li:before {:content "▢ "}]]
   [:table [:p {:margin 0}]]])

#+END_SRC

*** figures
#+BEGIN_SRC clojure :tangle ./src/stylo/style/base.cljc
(def figures
  [[:.figure {:padding-left (u/px 7)}]
   [:.figure [:p {:font-size "smaller"
                  :font-style "italic"}]]])

#+END_SRC

*** code
#+BEGIN_SRC clojure :tangle ./src/stylo/style/base.cljc
(def code
  [[:code.block {:padding (u/px 8)
                 :background "#2e3440"
                 :color "#dedee9"
                 :white-space "pre-wrap"
                 :display "inline-block"
                 :width (u/percent 100)}]])

#+END_SRC

#+RESULTS[2342df20361e21aa93ed992c794f248f81cefa1d]: style-base-code
: #'stylo.style.base/code

*** hidden
#+BEGIN_SRC clojure :tangle ./src/stylo/style/base.cljc
(def hidden
  [[:.hidden {:display "none"}]])

#+END_SRC
*** pagebreak
#+BEGIN_SRC clojure :tangle ./src/stylo/style/base.cljc
(def pagebreak
  [(at-media {:print ""}
             [:.pagebreak {:page-break-after "always"}])])

#+END_SRC

*** build
#+BEGIN_SRC clojure :tangle ./src/stylo/style/base.cljc
(def style
  (concat
   draw
   tables
   figures
   code
   hidden
   pagebreak))

(def style-str
  (css style))

#+END_SRC

** theme-mu
[[https://github.com/BafS/mu][mu]]
The mu theme is nice for documentation. I like it  for it's clean look and simple css.

*** ns
#+BEGIN_SRC clojure :tangle ./src/stylo/style/mu.cljc
(ns stylo.style.mu
  (:require [garden.core :refer [css]]
            [garden.stylesheet :refer [at-media]]
            [garden.units :as u]
            [stylo.style.base :as base]))

#+END_SRC

*** attribution
The license and attribution are in a comment header at the top of the original code, and shall be respected.

#+BEGIN_SRC clojure :tangle ./src/stylo/style/mu.cljc
(def license-str ""
"
/*!
MIT License

Copyright (c) 2016 Fabien Sa

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the \"Software\"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

")

(def attrib-str "" 
"
/*
| The mu framework v0.3.1
| BafS 2016-2018
*/

")

#+END_SRC

*** fonts
The theme has embedded fonts, which is perfect as the final rendered document will be fully usable offline. But, since the data is embedded, we want to import it from a file so that we're not cluttering up this file.

#+BEGIN_SRC clojure :tangle ./src/stylo/style/mu.cljc
(def fonts
  [[:* :*:after :*:before {:box-sizing "border-box"}]
   [:body {:font "18px/1.6 Georgia, \"Times New Roman\", Times, serif"}]
   [:table :input {:font-size (u/px 16)}]
   [:button :select {:font-size (u/px 14)}]
   [:h1 :h2 :h3 :h4 :h5 :h6 {:font-family "\"Helvetica Neue\", Helvetica, Arial, sans-serif"
                             :line-height 1.2}]])

#+END_SRC

*** page-setup
The page setup is most of the theme.

#+BEGIN_SRC clojure :tangle ./src/stylo/style/mu.cljc
(def page-setup
  [[:body {:margin [[(u/px 40) "auto"]]
           :max-width (u/px 760)
           :color "#444"
           :padding [[0 (u/px 20)]]}]
   [:a {:color "#07c"
        :text-decoration "none"}]
   [:a:hover {:color "#059"
              :text-decoration "underline"}]
   [:hr {:border 0
         :margin [[(u/px 25) 0]]}]])

#+END_SRC
*** tables
The table styling

#+BEGIN_SRC clojure :tangle ./src/stylo/style/mu.cljc
(def tables
  [[:table {:border-spacing 0
            :border-collapse "collapse"
            :text-align "left"
            :padding-bottom (u/px 25)}]
   [:td :th {:padding (u/px 5)
             :vertical-align "bottom"}]
   [:td :th :hr {:border-bottom [[(u/px 1) "solid" "#ddd"]]}]])

#+END_SRC

*** blocks
Block element styles

#+BEGIN_SRC clojure :tangle ./src/stylo/style/mu.cljc
(def blocks
  [[:pre {:padding (u/px 8)
          :white-space "pre-wrap"}]])

#+END_SRC

*** inputs
The styles for input type elements

#+BEGIN_SRC clojure :tangle ./src/stylo/style/mu.cljc
(def inputs
  [[:button :select {:background "#ddd"
                     :border 0
                     :padding [[(u/px 9) (u/px 20)]]}]
   [:input {:padding (u/px 5)
            :vertical-align "bottom"}]
   [:button:hover {:background "#eee"}]
   [:textarea {:border-color "#ccc"}]])

#+END_SRC

*** grid
The grid special classes

#+BEGIN_SRC clojure :tangle ./src/stylo/style/mu.cljc
(def grid
  [[:.row {:display "block"
           :width "auto"
           :min-height (u/px 1)}]
   [:.row:after {:content "\"\""
                 :display "table"
                 :clear "both"}]
   [:.row :.c {:float "left"}]
   [:table :.g2 :.g3 :.g3-2 :.m2 :.m3 :.m3-2 {:width (u/percent 100)}]
   
   [(at-media {:min-width (u/px 768)})
    [:.g2 {:width (u/percent 50)}]
    [:.m2 {:margin-left (u/percent 50)}]
    [:.g3 {:width (u/percent 33.33)}]
    [:.g3-2 {:width (u/percent 66.66)}]
    [:.m3 {:margin-left (u/percent 33.33)}]
    [:.m3-2 {:margin-left (u/percent 66.66)}]]])

#+END_SRC

*** build
Combine all of the definitions to build the style.

#+BEGIN_SRC clojure :tangle ./src/stylo/style/mu.cljc
(def style-str
  (str
   license-str
   attrib-str
   (css (concat
         fonts
         base/style
         page-setup
         tables
         blocks
         inputs
         grid))))

#+END_SRC
** alt-themes
I created .cljc files for a few other themes, which are in the following locations:

src/stylo/style/writ.cljc
src/stylo/style/latex.cljc
src/stylo/style/awsm.cljc

You can use them the same way mu is used in the stylo.builder library. They are cleared from the org file because I have not used them in practice.
* svg
This namespace has the SVG wrappers and nothing else. This means that the most useful elements listed here: [[https://developer.mozilla.org/en-US/docs/Web/SVG/Element]] are covered. More advanced SVG elements are currently not enabled, because the Stylo library focuses on creating simple diagrams and figures using the basics.

** ns
#+BEGIN_SRC clojure :tangle ./src/stylo/svg.cljc
(ns stylo.svg
  (:require [clojure.string :as s]
            [forge.proto :as f]
            #?(:cljs 
               [cljs.reader :refer [read-string]])))

#+END_SRC

** svg-element
#+BEGIN_SRC clojure :tangle ./src/stylo/svg.cljc
(defn svg
  [[w h sc] & content]
  [:svg {:width w
         :height h
         :viewBox (str "-1 -1 " w " " h)
         :xmlns "http://www.w3.org/2000/svg"}
   [:g {:transform (str "scale(" sc ")")} content]])

#+END_SRC

** string-helpers
*** misc
#+BEGIN_SRC clojure :tangle ./src/stylo/svg.cljc
(defn pt->str
  [pt]
  (apply str (interpose "," pt)))

(defn str->pt
  [s]
  (mapv read-string (s/split s #",")))

(defn points->str
  [pts]
  (apply str (interpose " " (map pt->str pts))))

(defn str->points
  [s]
  (mapv str->pt (s/split s #" ")))

(defn scale-str
  [sc]
  (str "scale(" sc ")"))

(defn translate-str
  [x y]
  (str "translate(" x " " y ")"))
 
(defn rotate-str
  ([r]
   (str "rotate(" r ")"))
  ([r [x y]]
   (str "rotate(" r " " x " " y ")")))

(defn hsl-str
  [h s l]
  (str "hsl(" h ", " s "%, " l "%)"))

#+END_SRC

*** transform-helpers
#+BEGIN_SRC clojure :tangle ./src/stylo/svg.cljc
(defn xf-kv->str
  [[k v]]
  (let [k (symbol k)
        v (apply list v)]
    (str k v)))

(defn str->xf-kv
  [s]
  (let [split (s/split s #"\(")
        key (keyword (first split))
        val (vec (read-string (str "(" (second split))))]
    [key val]))

(defn xf-map->str
  [m]
  (apply str (interpose "\n" (map xf-kv->str m))))

(defn str->xf-map
  [s]
  (if-let [s s]
    (into {} (map str->xf-kv (s/split-lines s)))
    {}))

#+END_SRC
** shapes
#+BEGIN_SRC clojure :tangle ./src/stylo/svg.cljc
(def svg-elements 
  #{:circle
    :ellipse
    :line
    :path
    :polygon
    :polyline
    :rect
    :text
    :g})

(defn element? [item]
  (svg-elements (first item)))

#?(:clj
   (defn check-svg-impl
     [multimethod]
     (println "Missing Implementation for:"
              (clojure.set/difference 
               svg-elements
               (into #{} (keys (methods multimethod)))))))

(defn circle
  [r]
  [:circle {:cx 0 :cy 0 :r r}])

(defn ellipse
  [rx ry]
  [:ellipse {:cx 0 :cy 0 :rx rx :ry ry}])

(defn line
  [[ax ay] [bx by]]
  [:line {:x1 ax :y1 ay :x2 bx :y2 by}])

(defn path
  [d]
  [:path {:d d
          :fill-rule "evenodd"}])

(defn polygon
  [pts]
  [:polygon {:points (points->str pts)}])

(defn polyline
  [pts]
  [:polyline {:points (points->str pts)}])

(defn rect
  [w h]
  [:rect {:width w :height h :x (/ w -2.0) :y (/ h -2.0)}])

(defn text
  [text]
  (let [char-w 9.625
        char-h 10
        n-chars (count text)
        x (/ (* n-chars char-w) -2.0)
        y (/ char-h 2.0)]
    [:text {:x (/ (* n-chars char-w) -2.0)
            :y (/ char-h 2.0)
            :transform (xf-map->str {:rotate [0 (- x) (- y)]})
            :style {:font-family "monospace"
                    :font-size 16}} text]))

(defn g
  [& content]
  (if (and (= 1 (count content))
           (not (keyword? (first (first content)))))
    ;; content is a list of a list of elements
    (into [:g {}] (first content))
    ;; content is a single element OR a list of elements
    (into [:g {}] (filter (complement nil?) content))))

(declare color-element)

#+END_SRC
** path
*** path-helpers
#+BEGIN_SRC clojure :tangle ./src/stylo/svg.cljc
;; types of paths line, arc, quadratic, cubic
(defn path->pts
  [s]
  (as-> s s
    (s/replace s #"Z" "") ;; removes Z at end of path
    (s/split s #"\s") ;; split string at spaces
    (mapcat #(s/split % #"[A-Za-z]") s) ;;splits on alpha chars
    (filter #(not (= % "")) s)
    (map read-string s)
    (vec (map vec (partition 2 s)))))

(defn path-type
  [s]
  (cond 
    (s/includes? s "L") :line
    (s/includes? s "l") :line
    (s/includes? s "C") :cubic
    (s/includes? s "c") :relative-cubic
    (s/includes? s "Q") :quadratic
    (s/includes? s "A") :arc))

(defn closed?
  [s]
  (= \Z (last s)))

(defmulti path-string->path
  (fn [s]
    (path-type s)))

(defmethod path-string->path :default
  [s]
  {:type (path-type s)
   :closed (closed? s)
   :pts (path->pts s)})

(defmethod path-string->path :arc
  [s]
  (let [xs (-> s
               (s/replace #"[A-Za-z]" "")
               (s/split #"\s")
               (#(filter (complement s/blank?) %)))
        [p1x p1y rx ry x-deg lg sw p3x p3y] xs]
    {:type :arc
     :closed (closed? s)
     :p1 [p1x p1y]
     :p3 [p3x p3y]
     :rx rx
     :ry ry
     :x-deg x-deg
     :lg lg
     :sw sw}))

(defn -str
  [leader & pts]
  (apply str (interpose " " (concat [leader] (flatten pts)))))

(defmulti path->path-string
  (fn [p]
    (:type p)))

(defmethod path->path-string :line
  [{:keys [closed pts]}]
  (let [[m & pts] pts]
    (str 
     (-str "M" m) " "
     (apply str (interpose " " (map (partial -str "L") pts)))
     (when closed " Z"))))

(defmethod path->path-string :quadratic
  [{:keys [closed pts]}]
  (let [[p1 c p2 & pts] pts]
    (str
     (-str "M" p1) " "
     (-str "Q" c p2) " "
     (apply str (interpose " "
                       (map #(apply (partial -str "T") %) (partition 2 pts))))
     (when closed " Z"))))

(defmethod path->path-string :cubic
  [{:keys [closed pts]}]
  (let [[p1 c1 c2 p2  & pts] pts]
    (str
     (-str "M" p1) " "
     (-str "C" c1 c2 p2) " "
     (apply str (interpose 
                 " " 
                 (map #(apply (partial -str "S") %) (partition 2 pts))))
     (when closed " Z"))))

(defmethod path->path-string :relative-cubic
  [{:keys [closed pts]}]
  (let [[p1 c1 c2 p2  & pts] pts]
    (str
     (-str "M" p1) " "
     (-str "c" c1 c2 p2) " "
     (apply str (interpose 
                 " " 
                 (map #(apply (partial -str "") %) (partition 2 pts))))
     (when closed " Z"))))

(defmethod path->path-string :arc
  [{:keys [p1 p3 rx ry x-deg lg sw closed]}]
  (str
   (-str "M" p1) " "
   (-str "A" [rx ry] [x-deg lg sw] p3)
   (when closed " Z")))

#+END_SRC

The path element has a small DSL to create compound curves. This includes the following (taken from [[https://www.w3schools.com/graphics/svg_path.asp]]):


    M = moveto
    L = lineto
    H = horizontal lineto
    V = vertical lineto
    C = curveto
    S = smooth curveto
    Q = quadratic Bézier curve
    T = smooth quadratic Bézier curveto
    A = elliptical Arc
    Z = closepath

*** polygon-path
#+BEGIN_SRC clojure :tangle ./src/stylo/svg.cljc
(defn path-polygon-str
  [[m & pts]]
  (str 
   (-str "M" m) " "
   (apply str 
          (interpose " " (map (partial -str "L") pts)))
   " Z"))

(defn path-polyline-str
  [[m & pts]]
  (str 
   (-str "M" m) " "
   (apply str 
          (interpose " " (map (partial -str "L") pts)))))

(defn centered-path-polygon
  [& pts]
  (let [m (f/midpoint (apply concat pts))
        xpts (for [spts pts] (mapv #(f/v- % m) spts))
        paths (map path-polygon-str xpts)]
    (path (apply str (interpose "\n" paths)))))

(defn centered-path-polyline
  [& pts]
  (let [m (f/midpoint (apply concat pts))
        xpts (for [spts pts] (mapv #(f/v- % m) spts))
        paths (map path-polyline-str xpts)]
    (path (apply str (interpose "\n" paths)))))

(defn path-polygon
  [& pts]
  (let [paths (map path-polygon-str pts)]
    (path (apply str (interpose "\n" paths)))))

(defn path-polyline
  [& pts]
  (let [paths (map path-polyline-str pts)]
    (path (apply str (interpose "\n" paths)))))

#+END_SRC

*** bezier
#+BEGIN_SRC clojure :tangle ./src/stylo/svg.cljc
(declare style-element)
(defn cubic-bezier-str
  [[x1 y1] [cx1 cy1] [cx2 cy2] [x y]]
  (let [m-str (str "M " x1 " " y1 " ")
        c-str (apply str (interpose " " ["C" cx1 cy1 cx2 cy2 x y]))]
    (str m-str c-str)))

(defn s-bezier-str
  [[cx1 cy1] [x y]]
  (apply str (interpose " " ["S" cx1 cy1 x y])))

(defn cubic-bezier
  [pts]
  (let [curve1 (apply cubic-bezier-str (take 4 pts))
        s-curves (map #(apply s-bezier-str %)
                      (partition 2 (drop 4 pts)))]
    (path 
     (apply str (interpose " " (cons curve1 s-curves))))))

#_(defn cubic-bezier-debug
  [pts]
  (let [curve1 (apply cubic-bezier-str (take 4 pts))
        s-curves (map #(apply s-bezier-str %)
                      (partition 2 (drop 4 pts)))]
    (g
     (style-element
      {:stroke "black"
       :stroke-width 1}
      (g
       (map #(translate % (circle 2)) pts)
       (polyline pts)))
     (path 
      (apply str (interpose " " (cons curve1 s-curves)))))))

#+END_SRC

*** arc
The arc command 

A rx ry x-axis-rotation large-arc-flag sweep-flag x y
 
a rx ry x-axis-rotation large-arc-flag sweep-flag dx dy

#+BEGIN_SRC clojure :tangle ./src/stylo/svg.cljc
(defn arc-str
  [rx ry x-deg lg sw x y]
  (apply str (interpose " " ["a" rx ry x-deg lg sw x y])))

;; arc drawing can be done in a few ways.
;; could implement different drawing methods w/ defmethod,
;; dispatch on :key OR on 'shape' of the args?

(defn large-arc-flag
  [p1 p2 p3]
  (let [[p1b p2b p3b] (map #(conj % 0) [p1 p2 p3])
        c (drop-last (f/center-from-pts p1b p2b p3b))
        a1 (f/angle-from-pts p1 c p2)
        a2 (f/angle-from-pts p2 c p3)
        a (+ a1 a2)]
    (if (< 180 a) 1 0)))

;; figure out how to properly set sweep flag.
;; this breaks when p1 and p3 are swapped (even though 
;; the arc should be drawn the same.. it also breaks
;; when p2 is in Q4

(defn sweep-flag
  [p1 p2 p3]
  (let [[p1b p2b p3b] (map #(conj % 0) [p1 p2 p3])
        c (drop-last (f/center-from-pts p1b p2b p3b))]
    (if (or (> (second p2) (second c))
            (> (first p2) (first c))) 0 1)))

(declare circle-by-pts)
(declare translate)
(declare rotate)
(declare scale)
(defn arc
  [p1 p2 p3]
  (let [[p1b p2b p3b] (map #(conj % 0) [p1 p2 p3]) 
        r (f/radius-from-pts p1b p2b p3b)
        m-str (apply str (interpose " " (cons "M" p1)))
        a-str (apply str 
                     (interpose " " (concat ["A" r r 0 
                                             (large-arc-flag p1 p2 p3)
                                             (sweep-flag p1 p2 p3)] p3)))]
    (g
     (circle-by-pts p1 p2 p3)
     (path (apply str (interpose " " [m-str a-str]))))))

#+END_SRC

*** combine-paths
These are prototype functions for now. They are used to build compound paths. That is, straight segments combined in various ways with curves. As well, it is necessary for faces with holes. Eg. a square with a smaller shape contained within.

#+BEGIN_SRC clojure :tangle ./src/stylo/svg.cljc
(defn merge-paths
  "Merges svg <path> elements together, keeping props from last path in the list."
  [& paths]
  (let [props (second (last paths))
        d (apply str (interpose "\n" (map #(get-in % [1 :d]) paths)))]
    [:path (assoc props :d d)]))

(defn join-paths
  [& paths]
  (let [props (second (last paths))
        strings (concat [(get-in (first paths) [1 :d])] 
                        (mapv #(s/replace (get-in % [1 :d]) #"M" "L") (rest paths)))
        d (apply str (interpose "\n" strings))]
    [:path (assoc props :d d)]))

(defn close-path
  [[k props]]
  (let [path-string (:d props)]
    [k (assoc props :d (str path-string " Z"))]))

#+END_SRC

** transforms
Transforms are translate, rotate, and scale. All transforms work well for most objects (:g and :text are exceptions). They all transform about the object's center point. This has the effect of 'local first' transformation.

This leads to challenges with groups. Groups must have their midpoint calculated such that rotation and translation can correctly occur about the group's midpoint. Otherwise, a group will not follow the same behaviour as any other element.

*** bounds
**** bounds-fn
#+begin_src clojure :results none :tangle ./src/stylo/svg.cljc
(defn pts->bounds
  [pts]
  (let [xmax (apply max (map first pts))
        ymax (apply max (map second pts))
        xmin (apply min (map first pts))
        ymin (apply min (map second pts))]
    (vector [xmin ymin]
            [xmax ymin]
            [xmax ymax]
            [xmin ymax])))

#+end_src

**** bounds-element
#+BEGIN_SRC clojure :results none :tangle ./src/stylo/svg.cljc
(defmulti bounds-element
  (fn [element]
    (first element)))

(defmethod bounds-element :circle
  [[_ props]]
  (let [c [(:cx props) (:cy props)]
        r (:r props)
        pts (mapv #(f/v+ c %) [[r 0]
                               [0 r]
                               [(- r) 0]
                               [0 (- r)]])]
    (pts->bounds pts)))

(declare rotate-pt-around-center)
(defmethod bounds-element :ellipse
  [[_ props]]
  (let [xf (str->xf-map (get props :transform "rotate(0 0 0)"))
        deg (get-in xf [:rotate 0])
        mx (get-in xf [:rotate 1])
        my (get-in xf [:rotate 2])
        c [(:cx props) (:cy props)]
        rx (:rx props)
        ry (:ry props)
        pts (mapv #(f/v+ c %) [[rx 0]
                               [0 ry] 
                               [(- rx) 0]
                               [0 (- ry)]])
        bb (pts->bounds pts)
        obb (mapv #(rotate-pt-around-center deg [mx my] %) bb)
        xpts (mapv #(rotate-pt-around-center deg [mx my] %) pts)
        small-bb (pts->bounds xpts)
        large-bb (pts->bounds obb)]
    ;; not accurate, but good enough for now
    ;; take the bb to be the average between the small and large
    (pts->bounds (mapv #(f/midpoint [%1 %2]) small-bb large-bb))))

(defmethod bounds-element :line
  [[_ props]]
  (let [a (mapv #(get % props) [:x1 :y1])
        b (mapv #(get % props) [:x2 :y2])]
    (pts->bounds [a b])))

(defmethod bounds-element :path
  [[_ props]]
  (let [path-strings (s/split-lines (:d props))
        paths (map (comp :pts path-string->path) path-strings)]
    (pts->bounds (apply concat paths))))

(defmethod bounds-element :polygon
  [[_ props]]
  (let [pts (str->points (:points props))]
    (pts->bounds pts)))

(defmethod bounds-element :polyline
  [[_ props]]
  (let [pts (str->points (:points props))]
    (pts->bounds pts)))

(defmethod bounds-element :rect
  [[_ props]]
  (let [xf (str->xf-map (get props :transform "rotate(0 0 0)"))
        deg (get-in xf [:rotate 0])
        mx (get-in xf [:rotate 1])
        my (get-in xf [:rotate 2])
        x (:x props)
        y (:y props)
        w (:width props)
        h (:height props)
        pts [[x y]
             [(+ x w) y]
             [(+ x w) (+ y h)]
             [x (+ y h)]]
        xpts (mapv #(rotate-pt-around-center deg [mx my] %) pts)]
    (pts->bounds xpts)))

;; this is not done yet. Text in general needs a redo.
(defmethod bounds-element :text
  [[_ props text]]
  [(:x props) (:y props)])

#+END_SRC

**** group-bounds
#+BEGIN_SRC clojure :tangle ./src/stylo/svg.cljc
(declare bounds)
(defmethod bounds-element :g
  [[_ props & content]]
  (pts->bounds (apply concat (map bounds content))))

#+END_SRC

**** interface
#+BEGIN_SRC clojure :tangle ./src/stylo/svg.cljc
(defn bounds
  [& elems]
  (let [elem (first elems)
        elems (rest elems)]
    (when elem
      (cond
        (and (element? elem) (= 0 (count elems)))
        (bounds-element elem)
        
        (and (element? elem) (< 0 (count elems)))
        (concat
         [(bounds-element elem)]
         [(bounds elems)])
      
        :else
        (recur (concat elem elems))))))

#+END_SRC

*** midpoint
**** midpoint-element
#+BEGIN_SRC clojure :tangle ./src/stylo/svg.cljc
(defmulti midpoint-element
  (fn [element]
    (first element)))

(defmethod midpoint-element :circle
  [[_ props]]
  [(:cx props) (:cy props)])  

(defmethod midpoint-element :ellipse
  [[_ props]]
  [(:cx props) (:cy props)])

(defmethod midpoint-element :line
  [[_ props]]
  (let [a (mapv #(get props %) [:x1 :y1])
        b (mapv #(get props %) [:x2 :y2])]
    (f/midpoint [a b])))

(defmethod midpoint-element :path
  [[_ props]]
  (let [path-strings (s/split-lines (:d props))
        paths (map (comp :pts path-string->path) path-strings)]
    (f/midpoint (apply concat paths))))

(defmethod midpoint-element :polygon
  [[_ props]]
  (let [pts (str->points (:points props))]
    (f/midpoint pts)))

(defmethod midpoint-element :polyline
  [[_ props]]
  (let [pts (str->points (:points props))]
    (f/midpoint pts)))

(defmethod midpoint-element :rect
  [[_ props]]
  [(+ (:x props) (/ (:width  props) 2.0))
   (+ (:y props) (/ (:height props) 2.0))])

;; this is not done yet. Text in general needs a redo.
(defmethod midpoint-element :text
  [[_ props text]]
  [(:x props) (:y props)])

#+END_SRC

**** group-midpoint
#+BEGIN_SRC clojure :tangle ./src/stylo/svg.cljc
(declare midpoint)
(defmethod midpoint-element :g
  [[_ props & content]]
  (f/midpoint (into #{} (map midpoint content))))

#+END_SRC

**** interface
#+BEGIN_SRC clojure :tangle ./src/stylo/svg.cljc
(defn midpoint
  [& elems]
  (let [elem (first elems)
        elems (rest elems)]
    (when elem
      (cond
        (and (element? elem) (= 0 (count elems)))
        (midpoint-element elem)
        
        (and (element? elem) (< 0 (count elems)))
        (concat
         [(midpoint-element elem)]
         [(midpoint elems)])
      
        :else
        (recur (concat elem elems))))))

#+END_SRC

*** translate
**** translate-element
#+BEGIN_SRC clojure :tangle ./src/stylo/svg.cljc
(defmulti translate-element 
  (fn [_ element]
    (first element)))

(defmethod translate-element :circle
  [[x y] [k props]]
  (let [xf (str->xf-map (get props :transform "rotate(0 0 0)"))
        cx (:cx props)
        cy (:cy props)
        new-xf (-> xf
                   (assoc-in [:rotate 1] (+ x cx))
                   (assoc-in [:rotate 2] (+ y cy)))
        new-props (-> props
                      (assoc :transform (xf-map->str new-xf))
                      (update :cx + x)
                      (update :cy + y))]
    [k new-props]))

(defmethod translate-element :ellipse
  [[x y] [k props]]
  (let [xf (str->xf-map (get props :transform "rotate(0 0 0)"))
        cx (:cx props)
        cy (:cy props)
        new-xf (-> xf
                   (assoc-in [:rotate 1] (+ x cx))
                   (assoc-in [:rotate 2] (+ y cy)))
        new-props (-> props
                      (assoc :transform (xf-map->str new-xf))
                      (update :cx + x)
                      (update :cy + y))]
    [k new-props]))

(defmethod translate-element :line
  [[x y] [k props]]
  (let [new-props (-> props
                      (update :x1 + x)
                      (update :y1 + y)
                      (update :x2 + x)
                      (update :y2 + y))]
    [k new-props]))

(defmethod translate-element :path
  [[x y] [k props]]
  (let [path-strings (s/split-lines (:d props))
        paths (map path-string->path path-strings)
        new-paths (for [path paths]
                    (let [xpts (map #(f/v+ [x y] %) (:pts path))]
                      (path->path-string (assoc path :pts xpts))))
        new-props (assoc props :d (apply str (interpose "\n" new-paths)))]
    [k new-props]))

(defmethod translate-element :polygon
  [[x y] [k props]]
  (let [points (str->points (:points props))
        new-points (points->str (map #(map + [x y] %) points))
        new-props (assoc props :points new-points)]
    [k new-props]))

(defmethod translate-element :polyline
  [[x y] [k props]]
  (let [points (str->points (:points props))
        new-points (points->str (map #(map + [x y] %) points))
        new-props (assoc props :points new-points)]
    [k new-props]))

(defmethod translate-element :rect
  [[x y] [k props]]
  (let [[mx my] (midpoint [k props])
        xf (str->xf-map (get props :transform "rotate(0 0 0)"))
        new-xf (-> xf
                   (assoc-in [:rotate 1] (+ mx x))
                   (assoc-in [:rotate 2] (+ my y)))
        new-props (-> props
                      (assoc :transform (xf-map->str new-xf))
                      (update :x + x)
                      (update :y + y))]
    [k new-props]))

(defmethod translate-element :text
  [[x y] [k props text]]
  (let [xf (str->xf-map (get props :transform "rotate(0 0 0)"))
        new-xf (-> xf
                   (update-in [:rotate 1] + x)
                   (update-in [:rotate 2] + y))
        new-props (-> props
                      (assoc :transform (xf-map->str new-xf))
                      (update :x + x)
                      (update :y + y))]
    [k new-props text]))

#+END_SRC

**** group-translate
#+BEGIN_SRC clojure :tangle ./src/stylo/svg.cljc
;; experimenting with transform that 'pushes through' group to instead map the translation onto all children in the group

#_(defmethod translate-element :g
  [[x y] [k props & content]]
  (let [xf (str->xf-map (:transform props))
        new-xf (-> xf
                   (update :translate (fnil #(map + [x y] %) [0 0])))
        new-props (assoc props :transform (xf-map->str new-xf))]
    (into [k new-props] content)))

(declare translate)
(defmethod translate-element :g
  [[x y] [k props & content]]
  (->> content
       (map (partial translate [x y]))
       (filter (complement nil?))
       (into [k props])))

#+END_SRC

**** interface
#+BEGIN_SRC clojure :tangle ./src/stylo/svg.cljc
(defn translate
  [[x y] & elems]
  (let [elem (first elems)
        elems (rest elems)]
    (when elem
      (cond
        (and (element? elem) (= 0 (count elems)))
        (translate-element [x y] elem)
        
        (and (element? elem) (< 0 (count elems)))
        (concat
         [(translate-element [x y] elem)]
         [(translate [x y] elems)])
      
        :else
        (recur [x y] (concat elem elems))))))

;; this is the 'old' way.
(defn translate-g
  [[x y] & elems]
  (into [:g {:transform (translate-str x y)}] elems))

#+END_SRC
*** rotate
**** rotate-element
#+BEGIN_SRC clojure :tangle ./src/stylo/svg.cljc
(defn rotate-element-by-transform
  [deg [k props content]]
  (let [xf (str->xf-map (get props :transform "rotate(0 0 0)"))
        new-xf (-> xf
                   (update-in [:rotate 0] + deg))
        new-props (assoc props :transform (xf-map->str new-xf))]
    [k new-props content]))

(defn rotate-pt
  [deg [x y]]
  (let [c (Math/cos (f/to-rad deg))
        s (Math/sin (f/to-rad deg))]
    [(- (* x c) (* y s))
     (+ (* x s) (* y c))]))

(defmulti rotate-element
  (fn [_ element]
    (first element)))

(defmethod rotate-element :circle
  [deg [k props]]
  (rotate-element-by-transform deg [k props]))

(defmethod rotate-element :ellipse
  [deg [k props]]
  (rotate-element-by-transform deg [k props]))

(defn move-pt
  [mv pt]
  (mapv + pt mv))

(defn rotate-pt-around-center
  [deg center pt]
  (->> pt
       (move-pt (map - center))
       (rotate-pt deg)
       (move-pt center)))

(defmethod rotate-element :line
  [deg [k props]] 
  (let [pts [[(:x1 props) (:y1 props)] [(:x2 props) (:y2 props)]]
        [[x1 y1] [x2 y2]]  (->> pts
                                (map #(f/v- % (f/midpoint pts)))
                                (map #(rotate-pt deg %))
                                (map #(f/v+ % (f/midpoint pts))))
        new-props (-> props
                      (assoc :x1 x1)
                      (assoc :y1 y1)
                      (assoc :x2 x2)
                      (assoc :y2 y2))]
    [k new-props]))
#+END_SRC


This is very buggy. It's got all sorts of problems, including mangling shapes as you change the angle of rotation.

Idea:
 - set center (c) as (first (:pts (first paths))) -> this is the first point that the user specifices when creating a path. Might not be correct, but did seem to fix rotation applied directly to path-polygon data
 
Algorithm:
- get list of pts that make up the path
- calculate the bounding-box center of these points
- translate to 0 0 by using the negative values of the bb-center
- apply rotation by calculating new position of all pts (use rotate-pt)
- translate new pts to original location by translating to bb-center

#+BEGIN_SRC clojure :tangle ./src/stylo/svg.cljc
(defmethod rotate-element :path
  [deg [k props]]
  (let [m (midpoint [k props])
        paths (map path-string->path (s/split-lines (:d props)))
        xpaths (for [path paths]
                    (let [xpts (->> (:pts path)
                                    (map #(f/v- % m))
                                    (map #(rotate-pt deg %))
                                    (map #(f/v+ % m)))]
                      (path->path-string (assoc path :pts xpts))))
        xprops (assoc props :d (apply str (interpose "\n" xpaths)))]
    [k xprops]))

#+END_SRC

#+BEGIN_SRC clojure :tangle ./src/stylo/svg.cljc
#_(defmethod rotate-element :polygon
  [deg [k props]]
  (let [points (str->points (:points props))
        center (f/midpoint points)
        new-points (points->str
                    (map 
                     (partial rotate-pt-around-center deg center)
                     points))
        new-props (assoc props :points new-points)]
    [k new-props]))

(defmethod rotate-element :polygon
  [deg [k props]]
  (let [m (midpoint [k props])
        pts (str->points (:points props))
        xpts (->> pts
                  (map #(f/v- % m))
                  (map #(rotate-pt deg %))
                  (map #(f/v+ % m))
                  (points->str))
        xprops (assoc props :points xpts)]
    [k xprops]))

(defmethod rotate-element :polyline
  [deg [k props]]
  (let [points (str->points (:points props))
        center (f/bb-center-2d points)
        new-points (points->str
                    (map 
                     (partial rotate-pt-around-center deg center)
                     points))
        new-props (assoc props :points new-points)]
    [k new-props]))

(defmethod rotate-element :rect
  [deg [k props]]
  (let [[mx my] (midpoint [k props])
        xf (str->xf-map (get props :transform "rotate(0 0 0)"))
        new-xf (-> xf
                   (update-in [:rotate 0] + deg)
                   (assoc-in  [:rotate 1] mx)
                   (assoc-in  [:rotate 2] my))
        new-props (assoc props :transform (xf-map->str new-xf))]
    [k new-props]))

(defmethod rotate-element :text
  [deg [k props text]]
  (rotate-element-by-transform deg [k props text]))

#+END_SRC

**** group-rotate
If I let the rotate 'pass through' a group, it rotates every child element locally. This has the effect of ignoring grouped elements that you do want to rotate about the group's center.

Each child of a group must be rotated around the group's midpoint.
So,
- find group midpoint
- apply rotation to children about group midpoint
  - rotate child by deg
  - translate child to new center (rotate its orig midpoint about group midpoint to find new position)



#+BEGIN_SRC clojure :tangle ./src/stylo/svg.cljc
(declare rotate)
#_(defmethod rotate-element :g
  [deg [k props & content]]
  (let [[gmx gmy] (f/midpoint (bounds (into [k props] content)))
        xfcontent (for [child content]
                    (let [m (midpoint child)
                          xfm (->> m
                                   (f/v- [gmx gmy])
                                   (rotate-pt 180)
                                   (rotate-pt deg)
                                   (f/v+ [gmx gmy]))]
                      (->> child
                           (translate (f/v* [-1 -1] m))
                           (rotate deg)
                           (translate xfm))))]
    (into [k props] (filter (complement nil?) xfcontent))))

(defmethod rotate-element :g
  [deg [k props & content]]
  (let [[gmx gmy] #_(midpoint (into [k props] content)) (f/midpoint (bounds (into [k props] content)))
        xfcontent (for [child content]
                    (let [ch (translate [(- gmx) (- gmy)] child)
                          m (midpoint ch)
                          xfm (->> m
                                   (rotate-pt deg)
                                   (f/v+ [gmx gmy]))]
                      (->> ch
                           (translate (f/v* [-1 -1] m))
                           (rotate deg)
                           (translate xfm))))]
    (into [k props] (filter (complement nil?) xfcontent))))

#+END_SRC

**** interface
#+BEGIN_SRC clojure :tangle ./src/stylo/svg.cljc
(defn rotate
  [deg & elems]
  (let [elem (first elems)
        elems (rest elems)]
    (when elem
      (cond
        (and (element? elem) (= 0 (count elems)))
        (rotate-element deg elem)
        
        (and (element? elem) (< 0 (count elems)))
        (concat
         [(rotate-element deg elem)]
         [(rotate deg elems)])
        
        :else
        (recur deg (concat elem elems))))))

;; old approach
(defn rotate-g
  [r [x y] & elems]
  (into [:g {:transform (rotate-str r [x y])}] elems))

#+END_SRC

*** scale
SVG items are assumed to be positioned and moved around from their bounding box centers. This means that scaling an element will NOT move it's center position.

**** scale-element
#+BEGIN_SRC clojure :tangle ./src/stylo/svg.cljc
(defn scale-element-by-transform
  [[sx sy] [k props & content]]
  (let [xf (str->xf-map (:transform props))
        new-xf (-> xf
                   (update :scale (fnil #(map * [sx sy] %) [1 1])))
        new-props (assoc props :transform (xf-map->str new-xf))]
    [k new-props] content))

(defmulti scale-element 
  (fn [_ element]
    (first element)))

;; transforms are applied directly to the properties of shapes.
;; I have scale working the same way. One issue is that scaling a circle
;; turns it into an ellipse. This impl WILL change the shape to ellipse if non-uniform scaling is applied.

(defmethod scale-element :circle
  [[sx sy] [k props]]
  (let [circle? (= sx sy)
        r (:r props)
        new-props (if circle?
                    (assoc props :r (* r sx))
                    (-> props
                        (dissoc :r)
                        (assoc :rx (* sx r))
                        (assoc :ry (* sy r))))
        k (if circle? :circle :ellipse)]
    [k new-props]))

(defmethod scale-element :ellipse
  [[sx sy] [k props]]
  (let [new-props (-> props
                      (update :rx #(* sx %))
                      (update :ry #(* sy %)))]
    [k new-props]))

;; find bounding box center
;; translate bb-center to 0 0
;; scale all x y values by * [sx sy]
;; translate back to original bb-center

(defmethod scale-element :line
  [[sx sy] [k props]]
  (let [[cx cy] (f/bb-center-2d [[(:x1 props) (:y1 props)]
                              [(:x2 props) (:y2 props)]])
        new-props (-> props
                      (update :x1 #(+ (* (- % cx) sx) cx))
                      (update :y1 #(+ (* (- % cy) sy) cy))
                      (update :x2 #(+ (* (- % cx) sx) cx))
                      (update :y2 #(+ (* (- % cy) sy) cy)))]
    [k new-props]))

(defn scale-pt-from-center
  [[cx cy] [sx sy] [x y]]
  [(+ (* (- x cx) sx) cx)
   (+ (* (- y cy) sy) cy)])

(defmethod scale-element :path
  [[sx sy] [k props]]
  (let [path-strings (s/split-lines (:d props))
        paths (map path-string->path path-strings)
        center (f/bb-center-2d (apply concat (map :pts paths)))
        new-paths (for [path paths]
                    (let [xf (partial scale-pt-from-center center [sx sy])
                          xpts (map xf (:pts path))]
                      (path->path-string (assoc path :pts xpts))))
        new-props (assoc props :d (apply str (interpose "\n" new-paths)))]
    [k new-props]))

(defmethod scale-element :polygon
  [[sx sy] [k props]]
  (let [points (str->points (:points props))
        center (f/bb-center-2d points)
        new-points (points->str
                    (map 
                     (partial scale-pt-from-center center [sx sy])
                     points))
        new-props (assoc props :points new-points)]
    [k new-props]))

(defmethod scale-element :polyline
  [[sx sy] [k props]]
  (let [points (str->points (:points props))
        center (f/bb-center-2d points)
        new-points (points->str
                    (map 
                     (partial scale-pt-from-center center [sx sy])
                     points))
        new-props (assoc props :points new-points)]
    [k new-props]))

(defmethod scale-element :rect
  [[sx sy] [k props]]
  (let [cx (+ (:x props) (/ (:width props) 2.0))
        cy (+ (:y props) (/ (:height props) 2.0))
        w (* sx (:width props))
        h (* sy (:height props))
        new-props (-> props
                      (assoc :width w)
                      (assoc :height h)
                      (update :x #(+ (* (- % cx) sx) cx))
                      (update :y #(+ (* (- % cy) sy) cy)))]
    [k new-props]))

(defmethod scale-element :text
  [[sx sy] [k props text]]
  (let [xf (str->xf-map (get props :transform "rotate(0 0 0)"))
        cx (get-in xf [:rotate 1])
        cy (get-in xf [:rotate 2])
        x (+ (* (- (:x props) cx) sx) cx)
        y (+ (* (- (:y props) cy) sy) cy)
        new-xf (-> xf
                   (assoc-in [:rotate 1] (- x))
                   (assoc-in [:rotate 2] (- y)))
        new-props (-> props
                      (assoc :transform (xf-map->str new-xf))
                      (assoc :x x)
                      (assoc :y y)
                      (update-in [:style :font-size] #(* % sx)))]
    [k new-props text]))

(defmethod scale-element :g
  [[sx sy] [k props & content]]
  (let [xf (str->xf-map (:transform props))
        new-xf (-> xf
                   (update :scale (fnil #(map * [sx sy] %) [1 1])))
        new-props (assoc props :transform (xf-map->str new-xf))]
    (into [k new-props] content)))
  
#+END_SRC

**** interface
#+BEGIN_SRC clojure :tangle ./src/stylo/svg.cljc
(defn scale
  [sc & elems]
  (let [[sx sy] (if (coll? sc) sc [sc sc])
        elem (first elems)
        elems (rest elems)]
    (when elem
      (cond
        (and (element? elem) (= 0 (count elems)))
        (scale-element [sx sy] elem)
        
        (and (element? elem) (< 0 (count elems)))
        (concat
         [(scale-element [sx sy] elem)]
         [(scale [sx sy] elems)])
        
        :else
        (recur [sx sy] (concat elem elems))))))

;; this is the old method
(defn scale-g
  [sc & elems]
  (into [:g {:transform (scale-str sc)}] elems))
#+END_SRC
*** style
Style transforms allow the user to change any attributes of svg elements that affect appearance. For instance, stroke color, stroke width, and fill.

To consider:
- classes/ids with style in a CSS file, how can user attach class/id tags?
- what is proper precedence for style data? should merge always put the 'newest' or keep the existing?

#+BEGIN_SRC clojure :tangle ./src/stylo/svg.cljc
(defn style-element
  [style [k props & content]]
  (into [k (merge props style)] content))

(defn color-element
  [color [k props & content]]
  (let [color {:fill "none"
               :stroke color}]
    (into [k (merge props color)] content)))

#+END_SRC

**** interface
#+BEGIN_SRC clojure :tangle ./src/stylo/svg.cljc
(defn color
  [style & elems]
  (let [elem (first elems)
        elems (rest elems)]
    (when elem
      (cond
        (and (element? elem) (= 0 (count elems)))
        (color-element style elem)
        
        (and (element? elem) (< 0 (count elems)))
        (concat
         [(color-element style elem)]
         [(color style elems)])
        
        :else
        (recur style (concat elem elems))))))

#+END_SRC
** composites
*** arrow
#+BEGIN_SRC clojure :tangle ./src/stylo/svg.cljc
(defn arrow
  [a b]
  [:g {}
   [:marker {:id "head"
             :orient "auto"
             :markerWidth "0.5"
             :markerHeight "1"
             :refX "0.025"
             :refY "0.25"}
    [:path {:d "M0,0 V0.5 L0.25,0.25 Z"
            :fill "black"}]]
   [:polyline {:marker-end "url(#head)"
               :stroke "black"
               :stroke-width "2"
               :fill "rgba(0,0,0,0)"
               :points (points->str [a b])}]])

#+END_SRC

*** circle-by-points
#+BEGIN_SRC clojure :tangle ./src/stylo/svg.cljc
(defn circle-by-pts
  [p1 p2 p3]
  (let [[p1 p2 p3] (map #(conj % 0) [p1 p2 p3]) 
        r (f/radius-from-pts p1 p2 p3)
        c (drop-last (f/center-from-pts p1 p2 p3))]
    (style-element
     {:fill "none"
      :stroke "gray"
      :stroke-width 1}
     (g
      (translate c (circle r))
      (translate c (circle 2))
      (translate (drop-last p1) (circle 2))
      (translate (drop-last p2) (circle 2))
      (translate (drop-last p3) (circle 2))))))

#+END_SRC

*** containers
 Containers are functions that wrap visual elements like 2D or 3D drawings.

#+BEGIN_SRC clojure :tangle ./src/stylo/svg.cljc
(defn figure
  [[w h sc fig-num] descr & content]
  [:div.figure
   (svg [w h sc] content)
   [:p 
    (when fig-num [:strong (str "Fig. " fig-num " ")]) 
    descr]])

(defn fig
  [fig-num descr & content]
  [:div.figure
   content
   [:p [:strong (str "Fig. " fig-num " ")] descr]])

(defn dwg-2d
  [[w h sc] & content]
  (let [view-str (apply str (interpose " " 
                                       [(/ w -2.0) (/ h -2.0) w h]))]
    (assoc-in (svg [w h sc] content) [1 :viewBox] view-str)))

(defn axes-2d
  []
  [:g#axes
   (map
    (partial style-element {:stroke-width 1})
    [(color "#a3be8c" (line [0 -1000] [0 1000]))
     (color "#bf616a" (line [-1000 0] [1000 0]))])])

#+END_SRC

*** dimensions-2d
#+BEGIN_SRC clojure :tangle ./src/stylo/svg.cljc
;; this fn will tell you the parameter that correspondss to the distance along the line

(comment
  (defn d->t
    [f d]
    (let [l (f/distance (f 0) (f 1))]
      (/ d l)))

  ;; fn will tell you the distance along the line that parameter's point is.
  (defn t->d
    [f t]
    (f/distance (f 0) (f t)))

  (defn dimension
    [a b]
    (let [text (str (round (f/distance a b) 3))
          label-offset (* 0.225 (count text))
          label-angle (f/to-deg (f/angle-between-lines-2d (f/brep-line a b) (f/brep-line [0 0] [1 0])))
          [ao bo] (f/offset-edge [a b] 2)
          mid (f/bb-center-2d [ao bo])
          arw-a (f/brep-line mid ao)
          arw-b (f/brep-line mid bo)
          arw-t (- 1 (d->t arw-a 0.5))
          mid-t (d->t arw-a (* 1.75 label-offset))
          la (f/brep-line a ao)
          lb (f/brep-line b bo)
          [lat1 lat2] (map (partial d->t la) [0.5 2.5])
          [lbt1 lbt2] (map (partial d->t lb) [0.5 2.5])]
      (list
       (arrow (arw-a mid-t) (arw-a arw-t))
       (arrow (arw-b mid-t) (arw-b arw-t))
       (line (la lat1) (la lat2))
       (line (lb lbt1) (lb lbt2))
       (translate (map - mid [label-offset 0]) (rotate label-angle [label-offset 0] (scale 1.5 (label text)))))))

  )

#+END_SRC

* shape
This ns is responsible for transforming shapes from the Forge library into SVG renderable data. 

** ns
#+BEGIN_SRC clojure :tangle ./src/stylo/shape.cljc
(ns stylo.shape
  (:require [forge.proto :as f]
            [forge.delaunay :as delaunay]
            [stylo.svg :as svg]))

#+END_SRC

** grid
A grid fn that creates even grids over parametric space.
*** old-sampling-fns
#+BEGIN_SRC clojure :tangle ./src/stylo/shape.cljc
(defn parametric-grid
  [nx ny]
  (for [x (conj (mapv float (range 0 1 (/ 1 nx))) 1)
        y (conj (mapv float (range 0 1 (/ 1 ny))) 1)]
    [x y]))

(defn sample-1
  [f step]
  (let [t (range 0 1 step)]
    (map f t)))

(defn sample-2
  [f & steps]
  (for [u (range 0 1 (first steps))
        v (range 0 1 (second steps))]
    (f u v)))

(defn sample
  [f & steps]
  (let [n-params (count steps)]
    (if (= 1 n-params)
      (sample-1 f (first steps))
      (sample-2 f (first steps) (second steps)))))

#_(defn quad-path
  [u v u-step v-step]
  [[u v]
   [(+ u u-step) v]
   [(+ u u-step) (+ v v-step)]
   [u (+ v v-step)]])


;; quad-mesh only makes sense for surfaces (f u v)
#_(defn quad-mesh
  [f u-step v-step]
  (for [u (range 0 1 u-step)
        v (range 0 1 v-step)]
    (map #(apply f %) (quad-path u v u-step v-step))))

#+END_SRC

*** subdivide
#+BEGIN_SRC clojure :tangle ./src/stylo/shape.cljc
(defn subdivide-curve
  [c n]
  (let [step-size (/ 1 n)]
    (mapv #(c (float %)) (conj (into [] (range 0 1 step-size)) 1))))

(defn quad-path
  [u v u-step v-step]
  [[u v]
   [(+ u u-step) v]
   [(+ u u-step) (+ v v-step)]
   [u (+ v v-step)]])

(defn subdivide-surface
  [s [nu nv]]
  (let [u-step (/ 1 nu)
        v-step (/ 1 nv)]
    (for [u (range 0 1 u-step)
          v (range 0 1 v-step)]
      (map #(apply s %) (quad-path u v u-step v-step)))))

#+END_SRC

** scene
*** scene-rotations
NOTE TO SELF:

Make sure naming convention actually matches what you are doing in designs.

For example, 'front-xf' apparently is actually a top view. 

This stems from being imprecise about which axes define a front plane. In the isometric transform, I treat Z as up, but the 'front-xf' assumes the XY plane is front. Thus, it is actually a top view when paired with isometric views. 

This is bad.

#+BEGIN_SRC clojure :tangle ./src/stylo/shape.cljc
(def iso-euler-angles [35.264 45 0])
(def origin-angle-adjust-a [90 0 0])
(def origin-angle-adjust-b [0 -90 0])

(defn rotate-points
  [pts [ax ay az]]
  (mapv #(f/rotate-point % [ax ay az]) pts))

(defn isometric-xf
  [pts]
  (-> pts
      (rotate-points origin-angle-adjust-a)
      (rotate-points origin-angle-adjust-b)
      (rotate-points iso-euler-angles)))

(defn top-xf
  [pts]
  (-> pts
      (rotate-points [0 0 0])))

(defn right-xf
  [pts]
  (-> pts
      (rotate-points [90 0 0])))

#+END_SRC

*** isometric-axes
#+BEGIN_SRC clojure :tangle ./src/stylo/shape.cljc
(defn drop-z
  [pts]
  (mapv #(into [] (drop-last %)) pts))

(def axes-iso
  (let [xpts (drop-z (isometric-xf [ [0 0 0] [5 0 0] ]))
        ypts (drop-z (isometric-xf [ [0 0 0] [0 5 0] ]))
        zpts (drop-z (isometric-xf [ [0 0 0] [0 0 5] ]))]
    [:g#axes
     (map
      (partial svg/style-element {:stroke-width "2px"})
      [(svg/color "#bf616a" (apply svg/line xpts))
       (svg/color "#a3be8c" (apply svg/line ypts))
       (svg/color "#5e81ac" (apply svg/line zpts))])]))

#+END_SRC

** triangulate-surface-proto
#+BEGIN_SRC clojure :tangle ./src/stylo/shape.cljc
(defn triangulate-surface
  [f grid]
  (as-> grid g
    (delaunay/triangulate g)
    (:triangles g)
    (into [] (apply concat g))
    (mapv #(apply f %) g)
    (into [] (partition 3 g))))

;; this is a bad name. 'render' implies creation of graphics... this only makes 2d points.

(defn draw-triangulation
  [triangles]
  (as-> triangles t
    (into [] (apply concat t))
    (isometric-xf t)
    (drop-z t)
    (into [] (partition 3 t))))

#+END_SRC

** curve-render
It may be smart to 'bake in' a curve's tag (in the forge library). For example, have brep-line return a pt as normal, but return a :line keyword when passed a :tag argument. Then, just assign curve resultions with a map.

#+BEGIN_SRC clojure :tangle ./src/stylo/shape.cljc
(def resolutions {:line 1
                  :circle 24})

#_(defn render-curve
  [c orientation-xf color]
  (let [res 10 ;; come up with method to select res dynamically
        pts (subdivide-curve c res)]
    (-> pts
        (orientation-xf)
        (drop-z)
        (svg/polyline)
        (#(svg/color color %)))))

(defn render-curve
  [c orientation-xf]
  (let [res 10 ;; come up with method to select res dynamically
        pts (subdivide-curve c res)]
    (-> pts
        (orientation-xf)
        (drop-z)
        (svg/polyline))))

(defn render-curves 
  [xf shape]
  (->> shape
       (:curves)
       (map #(render-curve % xf))
       (svg/g)))

#+END_SRC

** surface-render
#+BEGIN_SRC clojure :tangle ./src/stylo/shape.cljc
(defn render-subsurface
  [s orientation-xf style]
  (-> s
      (orientation-xf)
      (drop-z)
      (svg/polygon)
      (#(svg/style-element style %))))

#+END_SRC

This works, but destroys any possibility of coloring surfaces individually, as it applies style AFTER all subsurfaces are dissociated from their surface (that is, the surfaces are sorted globally, but style properties really need to be applied locally).

This might be fixable by storing style data just before sort time. Gons can be stored as [pts style] and sorted by essentially the same comp but with one more layer of destructuring.

You could potentially provide a cull filter before sort time too, using surface normal calculation. Any normal pointing away from the camera is cullable.

Furthermore, you could come up with a strategy to cull guaranteed hidden subsurfaces too. This might make more sense to do after transforming to screen coordinates, as you could use some sort of collision check. If any polygon about to be added exists completely inside the convex hull of existing polygons, you do NOT need to add it (assuming you add polygons from closest to camera to furthest away). NOTE: this is inverse order from my current naive implementation.

#+BEGIN_SRC clojure :tangle ./src/stylo/shape.cljc
(defn render-surfaces
  [shape xf style]
  (let [gons (mapcat #(subdivide-surface % [11 3]) (:surfaces shape))
        gons2 (reverse (sort-by (comp (partial f/distance [1000 1000 1000]) f/midpoint) gons))]
    (map #(render-subsurface % xf style) gons2)))

#+END_SRC

* parser
** ns
#+begin_src clojure :tangle ./src/stylo/parser.cljc
(ns stylo.parser
  (:require [clojure.string :as s]
            [instaparse.core :as insta]
            #?(:cljs 
               [cljs.reader :refer [read-string]])))

#+end_src
** parser
The base parser is derived in part from the following code:
https://github.com/danneu/klobbdown/blob/master/src/klobbdown/parse.clj

Things that don't work properly:
- indented bullet lists
- nested bullet lists
- '---' should be horizontal separator, doesn't work
- ordered lists don't work (numerical or alpha)
- '[' and ']' don't work inside a paragraph
- '{' and '}' don't work inside a paragraph
- embedded html renders, but does have extra paragraphs being inserted. it seems that newlines in html snippets are causing empty p tags to exist


- change names in the grammar to full-length names so that it's easier to read. eg. hd = heading, str = strong para = paragraph, etc.
- change the keys in the transform map to match the name changes.

- '-' and '!' sort of work. Both NEED a full line between anything preceding. Need to fix this to allow single newline paragraph separation.


#+BEGIN_SRC clojure :tangle ./src/stylo/parser.cljc
;; old kinda working unordered lists.
;; ul = ul-i+ <bl>
;; ul-i = <'- '> #'.+' <nl>?

(def -md ""
"<root> = (hd |
           ul |
           ol |
           code |
           anc |
           img |
           tb |
           ex |
           kl |
           kl-hidden |
           para)+

para = (i-code |
        anc |
        str |
        em |
        para-t)+ <nl> (<nl>+)?

<para-t> = #'[^`\\n*#{}\\[\\]]+'

hd = #'^#{1,} .+' <nl>? <bl>?

str = <'**'> str-t <'**'> 
<str-t> = #'[^\\*\\*]+'

em = <'*'> em-t <'*'>
<em-t> = #'[^\\*]+'

ul = ul-i+ <nl>
ul-i = <nl> <'- '> para-t <nl>?

ol = ol-i+ <bl>
ol-i = <ol-i-token> #'.*' <nl>?
ol-i-token = #'[0-9]+\\. '

i-code = <'`'> #'[^`]+' <'`'>
code = <'~~~'> lang? <nl> code-t <'\n~~~'> <bl>
lang = <' '> #'[a-zA-Z]+'
code-t = #'[^\\n~~~]+'

anc = a-anc | t-anc
<a-anc> = <'<'> url <'>'>
<t-anc> = <'['> text <']'> <'('> url <')'>
<text> = #'[^]]+'
<url> = #'[^>)]+'

img = <nl>? <'!'>
      <'['> alt <']'>
      <'('> path title? <')'> <nl> (<nl>+)?

<alt> = #'[^]]+'
<path> = #'[^) ]+'
<title> = <spcs> #'[^)]+'

spc = ' '
spcs = spc+
bl = #'\n\n'
nl = #'\n' ")

#+END_SRC

** extensions
#+BEGIN_SRC clojure :tangle ./src/stylo/parser.cljc
;; doc extensions
(defn gen-ext-str
  [tag]
  (let [main (str tag " = <'{" tag "}'> <nl> " tag "-t <'{" tag "}'> <bl>\n") 
        inner (str "<" tag "-t> = #'([\\s\\S]*?)(?=(\\{" tag "\\}))'")]
    (str main inner)))

(def -ex (gen-ext-str "ex"))
(def -tb (gen-ext-str "tb"))
(def -kl (gen-ext-str "kl"))
(def -kl-hidden (gen-ext-str "kl-hidden"))

;; fix this transform. It doesn't work without a fn being run

(defn transform-ex
  [text]
  (let [results (read-string (str "[" (s/replace text #"\n" "") "]"))
        vals (map eval results)]
    (for [val vals]
      (when (not (var? val))
        [:div val]))))

(defn transform-kl
  [text]
  [:div.cm-container [:code.clj.block text]])

(defn transform-kl-hidden
  [text]
  [:div.hidden [:code.clj.block text]])

#+END_SRC

** transformers
#+BEGIN_SRC clojure :tangle ./src/stylo/parser.cljc
(declare ->hiccup)
(declare doc-parse)
;; Transformers ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn transform-anchor
  ([url] [:a {:href url} url])
  ([text url] [:a {:href url} text]))

(defn transform-emphasis
  [text]
  [:em text])

(defn transform-strong
  [text]
  [:strong text])

(defn transform-pre-code
  ([text] [:pre [:code text]])
  ([lang text] [:pre [:code text]]))

(defn transform-inline-code
  [text]
  [:code text])

(defn transform-image
  ([alt path] [:img {:src path :alt alt}])
  ([alt path title] [:img {:src path :alt alt :title title}]))

(defn transform-unordered-item
  [item]
  [:li item])

(defn transform-unordered-list
  [& items]
  (into [:ul] items))

(defn transform-ordered-item
  [item]
  [:li item])

(defn transform-ordered-list
  [& items]
  (into [:ol] items))

(defn transform-paragraph
  [& items]
  (into [:p] items))

(defn transform-heading
  [text]
  (let [octothorpes (first (s/split text #" "))
        text (s/trim (s/replace text #"#" ""))
        level (count octothorpes)
        tag (keyword (str "h" level))]
    [tag text]))

(defn transform-table
  [text]
  (let [seq (map #(s/split % #"\|") (s/split text #"\|\n"))
        body [:tbody
              (for [row (rest seq)]
                (into [:tr] (mapv #(conj [:td] (->hiccup (doc-parse (str (s/trim %) "\n\n")))) (rest row))))]
        head [:thead
                 (into [:tr]
                       (mapv #(conj [:th] (->hiccup (doc-parse (str (s/trim %) "\n\n")))) (rest (first seq))))]]
    (conj [:table] head body)))

#+END_SRC

** to-hiccup 
#+BEGIN_SRC clojure :tangle ./src/stylo/parser.cljc
(def doc-parse (insta/parser (str -md -tb -ex -kl -kl-hidden)))

(defn ->hiccup
  [tree]
  (let [transformations {:anc transform-anchor
                         :em transform-emphasis
                         :str transform-strong
                         :img transform-image
                         :tb transform-table
                         :ex transform-ex
                         :kl transform-kl
                         :kl-hidden transform-kl-hidden
                         :code transform-pre-code
                         :i-code transform-inline-code
                         :ul-i transform-unordered-item
                         :ul transform-unordered-list
                         :ol-i transform-ordered-item
                         :ol transform-ordered-list
                         :hd transform-heading
                         :para transform-paragraph}]
    (insta/transform transformations tree)))

#+END_SRC

* builder
** ns
#+begin_src clojure :tangle ./src/stylo/builder.cljc
(ns stylo.builder
  (:require [clojure.string :as s]
            [hiccup.core :refer [h html]]
            [hiccup.def :refer [defelem]]
            [hiccup.page :as page]
            [hiccup.form :as form]
            [hiccup.element :as elem]
            [stylo.parser :refer :all]
            [stylo.style.mu :as mu]))

#+end_src

** compiler
#+BEGIN_SRC clojure :tangle ./src/stylo/builder.cljc
(defn md->html
  "Parses markup into HTML."
  [markup]
  (html (->hiccup (doc-parse markup))))

(defn discern-title
  [markup]
  (let [t (first (s/split-lines markup))]
    (-> t
        (s/replace #"#" "")
        (s/trim))))

(defn md->page
  "compiles markup into a valid HTML5 string."
  [markup]
  (s/replace
   (hiccup.page/html5
    (concat [[:head
              [:meta {:charset "utf-8"}]
              [:title (discern-title markup)]
              [:style mu/style-str]]]
            [[:body [:main (->hiccup (doc-parse markup))]]]))
   #"><" ">\n<"))

(def klipse-settings "
window.klipse_settings = {
  selector: '.clj',
  codemirror_options_in: {
    lineWrapping: true,
    theme: 'nord',
  },
  codemirror_options_out: {
    lineWrapping: true,
    theme: 'nord',
  }
}
")

(def codemirror-style "
.cm-container {
  box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.4), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
  font-size: 10pt;
  margin: 0 auto;
  max-width: 520px;
}
.CodeMirror {
  border: none;
  padding: 8px;
}
")

(defn contains-klipse?
  [markup]
  (s/includes? markup "{kl}"))

(defn md->klipse
  [markup]
  (s/replace
   (hiccup.page/html5
    (concat [[:head
              [:meta {:charset "utf-8"}]
              [:title (discern-title markup)]
              [:style mu/style-str]]]
            [[:body
              [:main (->hiccup (doc-parse markup))]
              (when (contains-klipse? markup) (list
                [:link {:rel "stylesheet"
                        :type "text/css"
                        :href "https://unpkg.com/klipse@7.9.6/dist/codemirror.css"}]
                [:link {:rel "stylesheet"
                        :type "text/css"
                        :href "https://codemirror.net/theme/nord.css"}]
                [:style codemirror-style]
                [:script klipse-settings]
                [:script {:src "https://unpkg.com/klipse@7.9.6/dist/klipse_plugin.js"}]))]]))
   #"><" ">\n<"))

#+END_SRC

** main
The main fn is invoked via a terminal. The idea is to pipe markdown strings into stylo and recieve html out.

With more args sent to main, different actions can occur. For instance, if you pass in a string and file, it can compile the string to that file. If you give two filenames, it converts the one into the other. If you give only one file, it converts it to html or errors out on invalid markup file.

A watcher will be nice too, which can either be invoked with a flag to -main OR by calling a different alias in deps.edn. Either way, the watcher will watch a single file and start a server that reloads when only that file changes. This will allow you to quickly spawn a live-reload environment to author with.

#+BEGIN_SRC clojure :tangle ./src/stylo/builder.cljc
(defn get-name
  [fpath]
  (first (s/split (last (s/split fpath #"/")) #"\.")))

(defn get-path
  [fpath]
  (let [fname (last (s/split fpath #"/"))]
    (s/replace fpath fname "")))

(defn -main [fpath]
  (let [markup (slurp fpath)
        name (get-name fpath)
        opath (get-path fpath)
        fname (str name ".html")]
    (do 
      (spit (str opath fname) (md->klipse markup))
      (println (str "created: " fname)))))

#+END_SRC
* extensions
Extensions are currently saved into src/stylo/ext/ext_name.cljc

Extensions are used to add functionality to the library that is clearly separated fom the core. The *fabric* extension is a great example: It has clear use in the context of creating quilt patterns, but is not general enough to be necessary in the core library.

Fabric uses many functions from the *draw* namespace, but any new functionality is useful in the specific domain that the extension covers, which is quilt patterns in this case. For instance, the 'template' function uses polygon and offset, but creates a 'piece' that only really makes sense in quilts.

** fabric
The extension used for creating quilt patterns. I think eventually I will separate things out into a program called qpunk which can be used specifically for creating quilt patterns. Qpunk would then pull in stylo as a library.

*** ns
#+BEGIN_SRC clojure :tangle ./src/stylo/ext/fabric.cljc
(ns stylo.ext.fabric
  (:require [clojure.string :as s]
            [stylo.draw :as draw]
            [stylo.svg :as svg]))

#+END_SRC

*** styles
#+BEGIN_SRC clojure :tangle ./src/stylo/ext/fabric.cljc
(def fabric-styles
  [:style "
.ln{stroke:#2e3440;stroke-width:1.5;}
.ln-d{stroke:#2e3440;stroke-width:1.5;stroke-linecap:round;stroke-dasharray:4, 5;}
rect, line, path, polygon, polyline {vector-effect:non-scaling-stroke;}
.attn{fill:rgb(234,82,111);}
.clr{fill:rgba(0,0,0,0);}
"])

#+END_SRC

*** shapes
#+BEGIN_SRC clojure :tangle ./src/stylo/ext/fabric.cljc
(defn sq
  ([s]
   (sq s nil))
  ([s class]
   [:rect {:class ["ln" (if class class "clr")]
           :width s
           :height s}]))

(defn rct
  ([[x y]]
   (rct [x y] nil))
  ([[x y] class]
   [:rect {:class ["ln" (if class class "clr")]
           :width x
           :height y}]))

(defn hst
  ([s]
   (hst s nil))
  ([s class]
   [:polygon {:class ["ln" (if class class "clr")]
              :points (svg/pt-str [[0 s] [s 0] [0 0]])}]))

(defn hst-pts
  [s]
  [[0 0] [s 0] [0 s]])

(defn diamond
  "draw a diamond of width and height with width offset and height offset factors."
  ([[w h wof hof]]
   (diamond [w h wof hof] nil))
  ([[w h wof hof] class]
   (let [wod (* w wof)
         hod (* h hof)]
     [:polygon {:class ["ln" (if class class "clr")]
                :points (svg/pt-str [[wod 0]
                                 [w hod]
                                 [wod h]
                                 [0 hod]])}])))

(defn diamond-pts
  [x y y2]
  (let [x2 (/ x 2.0)]
    [[x2 0]
     [x y2]
     [x2 y]
     [0 y2]]))

#+END_SRC

*** tools
#+BEGIN_SRC clojure :tangle ./src/stylo/ext/fabric.cljc
(defn stack
  [elem n]
  (let [spc 0.185
        tfrms (map #(vector (* % spc) (* % spc)) (range n))]
    [:g {}
     (map 
      (fn [[x y]] [:g {:transform (svg/translate-str x y)} elem]) 
      tfrms)]))

(def scale-1-to-1 146)

(defn polygon-template
  [name pts]
  (list
   (svg/polygon pts)
   (svg/polygon (draw/offset pts 0.25))
   (svg/translate (draw/bb-center pts) (svg/label name))
   (map #(svg/translate % (svg/scale 0.25 (svg/dot [0 0]))) pts)))

(defn diamond-template
  [name w h hof]
  (let [pts (diamond-pts w h hof)
        half-w (/ w 2.0)]
    (concat
     (polygon-template name pts)
     (draw/ln-d [half-w 0] [half-w h]))))

(defn colourize-template
  [template colour]
  (assoc-in (second template) [1 :class] (str "ln " colour)))

(defn seamless-piece
  [template colour]
  (assoc-in (first template) [1 :class] (str "ln " colour)))

#+END_SRC

*** blueberry-method-snippet
This is used in every pattern, so it makes sense to pull it into its own function for easy re-use.

#+BEGIN_SRC clojure :tangle ./src/stylo/ext/fabric.cljc

(def bb-heading
  [:h2 
   [:img {:style "width:50px;padding-right:10px;display:inline;"
          :src "./berry.png"}] 
   "The Blueberry Method"])

(def bb-instructions
  [:ol
   [:li "Draw a diagonal line on the wrong side of 4 squares designated for the Blueberry."]
   [:li "Place a Blueberry square RST onto the corners that meet in the middle of 4 selected units. Sew on the diagonal lines. Press two towards the corner, and then press the opposite two away from the corner. This will help to nest the seams together when completing The Blueberry. Trim."]
   [:li "Sew the seams together and your Blueberry will be complete."]])

(defn bb-a
  [berry-b]
  (list
   (sq 1.25 berry-b)
   (draw/ln-d [-0.1 1.35] [1.35 -0.1])))

(defn bb-b
  [berry-b col]
  (list
   (sq 2.5 col)
   (draw/mv [1.25 1.25] (bb-a berry-b))))

(defn bb-c
  [berry-b col]
  (list
   (sq 2.5 col)
   (draw/mv [1.25 1.25] (bb-a berry-b))
   (draw/mv [1.4 1.4] (draw/rot 180 [0.625 0.625] (hst 1.25 "trim"))
            (draw/mv [0.075 0.075] (draw/rot 180 [0.55 0.55] (hst 0.95 berry-b))))))

(defn bb-d
  [berry-f col out?]
  (list
   (sq 2.5 col)
   (draw/mv [1.25 1.25] (draw/rot 180 [0.625 0.625] (hst 1.25 berry-f))
       (if out?
         [:g {:transform "scale(0.625)"} (draw/arw [-0.1 -0.1] [1.35 1.35])]
         [:g {:transform "scale(0.625)"} (draw/arw [1.35 1.35] [-0.1 -0.1])]))))

(defn bb-e
  [berry-f col]
  (list
   (sq 2 col)
   (draw/mv [1.25 1.25] (draw/rot 180 [0.375 0.375] (hst 0.75 berry-f)))))

(defn bb-method
  "Blueberry Method Snippet expecting strings of CSS classes for each colour in the diagram.

  berry-f is the front berry colour.
  berry-b is the back berry colour.
  a is top left square colour.
  b is top right square colour.
  c is bottom right square colour.
  d is bottom left square colour."
  [berry-f berry-b col-a col-b col-c col-d]
  [:div.bb-method
   bb-heading
   bb-instructions
   [:div {:class "figure"}
    (draw/svg [700 160 22.5]
         (draw/mv [0.1 1.25]
             (bb-a berry-b)
             (draw/mv [1.75    0] (draw/rot  90 [0.625 0.625] (bb-a berry-b)))
             (draw/mv [1.75 1.75] (draw/rot 180 [0.625 0.625] (bb-a berry-b)))
             (draw/mv [   0 1.75] (draw/rot 270 [0.625 0.625] (bb-a berry-b))))
         (draw/mv [0.5 5.375] (draw/label "mark on"))
         (draw/mv [0.175 6.25] (draw/label "wrong side"))
         
         (draw/mv [5 0]
             (bb-b berry-b col-a)
             (draw/mv [3 0] (draw/rot  90 [1.25 1.25] (bb-b berry-b col-b)))
             (draw/mv [3 3] (draw/rot 180 [1.25 1.25] (bb-b berry-b col-c)))
             (draw/mv [0 3] (draw/rot 270 [1.25 1.25] (bb-b berry-b col-d))))
         (draw/mv [5.825 6.25] (draw/label "sew diagonals"))
         
         (draw/mv [12.25 0]
             (bb-c berry-b col-a)
             (draw/mv [3 0] (draw/rot  90 [1.25 1.25] (bb-c berry-b col-b)))
             (draw/mv [3 3] (draw/rot 180 [1.25 1.25] (bb-c berry-b col-c)))
             (draw/mv [0 3] (draw/rot 270 [1.25 1.25] (bb-c berry-b col-d))))
         (draw/mv [14.625 6.25] (draw/label "trim"))
         
         (draw/mv [19.5 0]
             (bb-d berry-f col-a false)
             (draw/mv [3 0] (draw/rot  90 [1.25 1.25] (bb-d berry-f col-b true)))
             (draw/mv [3 3] (draw/rot 180 [1.25 1.25] (bb-d berry-f col-c false)))
             (draw/mv [0 3] (draw/rot 270 [1.25 1.25] (bb-d berry-f col-d true))))
         (draw/mv [21.625 6.25] (draw/label "press"))
         
         (draw/mv [26.75 0.5]
             (bb-e berry-f col-a)
             (draw/mv [2 0] (draw/rot  90 [1 1] (bb-e berry-f col-b)))
             (draw/mv [2 2] (draw/rot 180 [1 1] (bb-e berry-f col-c)))
             (draw/mv [0 2] (draw/rot 270 [1 1] (bb-e berry-f col-d))))
         (draw/mv [27.5 6.25] (draw/label "sew seams")))

    [:p "Blueberry Point Method"]]])

#+END_SRC
